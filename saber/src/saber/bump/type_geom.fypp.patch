--- /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/type_geom.fypp.tmp	2024-06-12 18:33:06.558317975 +0200
+++ /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/type_geom.fypp	2024-06-11 11:30:46.086079373 +0200
@@ -9,18 +9,20 @@
 !----------------------------------------------------------------------
 module type_geom
 
-use atlas_module, only: atlas_field,atlas_functionspace,atlas_functionspace_nodecolumns,atlas_functionspace_pointcloud, &
- & atlas_functionspace_structuredcolumns,atlas_mesh_nodes,atlas_structuredgrid
+use atlas_module, only: atlas_config,atlas_connectivity,atlas_field,atlas_functionspace, &
+ & atlas_functionspace_nodecolumns,atlas_functionspace_pointcloud,atlas_functionspace_structuredcolumns,atlas_mesh, &
+ & atlas_mesh_nodes,atlas_projection,atlas_structuredgrid
+! TODO(Benjamin): This should be removed once spack-stack uses the ATLAS version where this interface is merged
+use atlas_buildnode2cellconnectivity, only: atlas_build_node_to_cell_connectivity
 use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max,fckit_mpi_status
 !$ use omp_lib
 use tools_atlas, only: get_grid,field_to_array,get_atlas_functionspace_size
-use tools_const, only: zero,quarter,half,one,two,four,hundred,pi,req,deg2rad,rad2deg,reqkm
+use tools_const, only: zero,quarter,half,one,two,three,four,hundred,pi,req,deg2rad,rad2deg,reqkm
 use tools_func, only: fletcher32,lonlatmod,grid_hash,independent_levels,sphere_dist,lonlat2xyz,xyz2lonlat,cart_dist, &
- & vector_product,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_l2i,convert_i2l,zss_maxval,zss_minval,zss_sum,zss_count
+ & vector_product,area,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_l2i,convert_i2l,zss_maxval,zss_minval,zss_sum,zss_count
 use tools_kinds, only: kind_int,kind_real,huge_real,huge_int
 use tools_qsort, only: qsort
 use tools_repro, only: inf,sup,eq,infeq,supeq,indist,repro_th
-use tools_stripack, only: area
 use type_bnda, only: bnda_type
 use type_com, only: com_type
 use type_fieldset, only: fieldset_type
@@ -43,14 +45,23 @@
 
    ! Input metadata
    logical,allocatable :: owned_mga(:,:)              !< Owned vs Halo/BC
-   logical :: area_provided                           !< Activated if areas are provided
-   logical :: global                                  !< Global grid (regional if false)
+
+   ! Grid/function space type
+   character(len=1024) :: grid_type                   !< Grid type ('global','regional_structuredcolumns','regional_nodecolumns')
+
+   ! Regional grid parameters
+   type(atlas_projection) :: aproj                    !< ATLAS projection
+   real(kind_real) :: lon_center                      !< Center longitude
+   real(kind_real) :: lat_center                      !< Center latgitude
+   real(kind_real) :: xmin                            !< Computational grid minimum x value
+   real(kind_real) :: xmax                            !< Computational grid maximum x value
+   real(kind_real) :: ymin                            !< Computational grid minimum y value
+   real(kind_real) :: ymax                            !< Computational grid maximum y value
 
    ! Geometry data on model grid, halo A
    integer :: nmga                                    !< Halo A size for model grid
    real(kind_real),allocatable :: lon_mga(:)          !< Longitudes
    real(kind_real),allocatable :: lat_mga(:)          !< Latitudes
-   real(kind_real),allocatable :: area_mga(:)         !< Areas
    real(kind_real),allocatable :: vert_coord_mga(:,:) !< Generalized vertical coordinate
    logical,allocatable :: gmask_mga(:,:)              !< Geometry mask
    type(atlas_functionspace) :: afunctionspace_mg     !< ATLAS function space of model grid
@@ -70,7 +81,6 @@
    logical :: same_grid                               !< Same grid and distribution flag
    real(kind_real),allocatable :: lon_c0a(:)          !< Longitudes
    real(kind_real),allocatable :: lat_c0a(:)          !< Latitudes
-   real(kind_real),allocatable :: area_c0a(:)         !< Area
    real(kind_real),allocatable :: vert_coord_c0a(:,:) !< Generalized vertical coordinate
    logical,allocatable :: gmask_c0a(:,:)              !< Geometry mask
    logical,allocatable :: gmask_hor_c0a(:)            !< Union of horizontal geometry masks
@@ -85,18 +95,12 @@
    logical,allocatable :: gmask_c0u(:,:)              !< Geometry mask
    logical,allocatable :: gmask_hor_c0u(:)            !< Union of horizontal geometry masks
    real(kind_real),allocatable :: mdist_c0u(:,:)      !< Minimum distance to mask
-   real(kind_real) :: area_max_c0u                    !< Area maximum on universe
 
    ! Geometry data on subset Sc0, global
    integer :: nc0                                     !< Number of subset Sc0 points
    integer,allocatable :: proc_to_c0_offset(:)        !< Processor to offset on subset Sc0
-   real(kind_real) :: lon_min                         !< Minimum longitude
-   real(kind_real) :: lon_max                         !< Maximum longitude
-   real(kind_real) :: lat_min                         !< Minimum latitude
-   real(kind_real) :: lat_max                         !< Maximum latitude
-   real(kind_real) :: sin_lat_min                     !< Minimum latitude sinus
-   real(kind_real) :: sin_lat_max                     !< Maximum latitude sinus
    integer,allocatable :: nc0_gmask(:)                !< Horizontal mask size on subset Sc0
+   real(kind_real) :: area                            !< Domain area
    real(kind_real),allocatable :: area_ver_c0(:)      !< Area profile on subset Sc0
    real(kind_real) :: area_max_c0                     !< Area maximum on subset Sc0
 
@@ -131,7 +135,8 @@
    ! Boundaries
    type(bnda_type) :: bnda_c0u                        !< Boundaries on subset Sc0, universe
 
-   ! Hull
+   ! Hulls
+   type(hull_type) :: hull_mg                         !< Domain hull on model grid, global
    type(hull_type) :: hull_c0u                        !< Domain hull on subset Sc0, universe
 
    ! Dirac fields for variables
@@ -221,7 +226,6 @@
 if (allocated(geom%il0rz)) deallocate(geom%il0rz)
 if (allocated(geom%lon_mga)) deallocate(geom%lon_mga)
 if (allocated(geom%lat_mga)) deallocate(geom%lat_mga)
-if (allocated(geom%area_mga)) deallocate(geom%area_mga)
 if (allocated(geom%vert_coord_mga)) deallocate(geom%vert_coord_mga)
 if (allocated(geom%myuniverse)) deallocate(geom%myuniverse)
 if (allocated(geom%proc_to_nc0a)) deallocate(geom%proc_to_nc0a)
@@ -286,7 +290,6 @@
 if (allocated(geom%c0a_to_mga)) deallocate(geom%c0a_to_mga)
 if (allocated(geom%lon_c0a)) deallocate(geom%lon_c0a)
 if (allocated(geom%lat_c0a)) deallocate(geom%lat_c0a)
-if (allocated(geom%area_c0a)) deallocate(geom%area_c0a)
 if (allocated(geom%vert_coord_c0a)) deallocate(geom%vert_coord_c0a)
 if (allocated(geom%gmask_c0a)) deallocate(geom%gmask_c0a)
 if (allocated(geom%l0_to_l0i)) deallocate(geom%l0_to_l0i)
@@ -366,7 +369,7 @@
 ! Setup hull
 write(mpl%info,'(a7,a)') '','Setup hull'
 call mpl%flush
-if (geom%global.and.all(geom%myuniverse)) then
+if ((geom%grid_type=='global').and.all(geom%myuniverse)) then
    geom%hull_c0u%radius = mpl%msv%valr
 else
    call geom%hull_c0u%init(mpl,geom%nc0u,geom%lon_c0u,geom%lat_c0u,nam%universe_radius)
@@ -491,15 +494,22 @@
 type(fieldset_type),intent(in),optional :: fieldset    !< Fieldset
 
 ! Local variables
-integer :: il0,imga
-real(kind_real) :: lon0,lat0,dist,maxdist
-real(kind_real),allocatable :: area_mga(:,:)
+integer :: il0,imga,ny,nx_inf,nx_sup,ib,ix,iy,icorner,jcorner,ncorner,iproc
+integer :: imga_bnd(4),proc_to_ncorner(mpl%nproc),opposite_index(1)
+integer,pointer :: ghost(:)
+real(kind_real) :: lon0,lat0,dist,maxdist,xcen,ycen,area_124,area_234
+real(kind_real) :: lonlat(2),lonlat_bnd(2,4),vbnd(3,4),vp(3),v1(3),v2(3),cp(3),cd(3),vtmp(3),vbnd_cen(3),dist_with_1(3)
 real(kind_real),pointer :: real_ptr(:,:)
-type(atlas_field) :: afield,afield_lonlat
+type(atlas_config) :: aconfig_grid,aconfig_domain,aconfig_proj
+type(atlas_field) :: afield,afield_lonlat,afield_ghost
 type(atlas_functionspace_nodecolumns) :: afunctionspace_nc
 type(atlas_functionspace_pointcloud) :: afunctionspace_pc
 type(atlas_functionspace_structuredcolumns) :: afunctionspace_sc
+type(atlas_structuredgrid) :: agrid_sc
+type(atlas_mesh) :: amesh
 type(atlas_mesh_nodes) :: anodes
+type(atlas_connectivity) :: aconnectivity
+character(len=:),allocatable :: domain_type
 
 ! Set name
 @:set_name(geom_from_atlas)
@@ -525,7 +535,6 @@
 
 ! Default values
 geom%owned_mga = .true.
-geom%area_provided = .false.
 do il0=1,geom%nl0
    geom%vert_coord_mga(:,il0) = real(il0,kind_real)
 end do
@@ -539,18 +548,6 @@
       call afield%final()
    end if
 
-   ! Get area
-   if (fieldset%has_field('area')) then
-      afield = fieldset%field('area')
-      allocate(area_mga(geom%nmga,1))
-      call field_to_array(afield,mpl,area_mga)
-      allocate(geom%area_mga(geom%nmga))
-      geom%area_mga = area_mga(:,1)/req**2
-      deallocate(area_mga)
-      call afield%final()
-      geom%area_provided = .true.
-   end if
-
    ! Get vertical coordinate
    if (nam%vert_coord_name /= "") then
       afield = fieldset%field(nam%vert_coord_name)
@@ -570,7 +567,7 @@
 select case (afunctionspace%name())
 case ('NodeColumns')
    ! Get node columns function space
-   afunctionspace_nc = atlas_functionspace_nodecolumns(afunctionspace%c_ptr())
+   afunctionspace_nc = afunctionspace
 
    ! Get lon/lat field
    anodes = afunctionspace_nc%nodes()
@@ -582,7 +579,7 @@
    end if
 case ('PointCloud')
    ! Get point cloud function space
-   afunctionspace_pc = atlas_functionspace_pointcloud(afunctionspace%c_ptr())
+   afunctionspace_pc = afunctionspace
 
    ! Get lon/lat field
    afield_lonlat = afunctionspace_pc%lonlat()
@@ -593,7 +590,7 @@
    end if
 case ('StructuredColumns')
    ! Get structured columns function space
-   afunctionspace_sc = atlas_functionspace_structuredcolumns(afunctionspace%c_ptr())
+   afunctionspace_sc = afunctionspace
 
    ! Get lon/lat
    afield_lonlat = afunctionspace_sc%xy()
@@ -611,7 +608,7 @@
    if (geom%owned_mga(imga,1)) call lonlatmod(geom%lon_mga(imga),geom%lat_mga(imga))
 end do
 
-! Get domain type
+! Get other grid properties
 if (mpl%main) then
    lon0 = geom%lon_mga(1)
    lat0 = geom%lat_mga(1)
@@ -626,26 +623,154 @@
    end if
 end do
 call mpl%f_comm%allreduce(maxdist,fckit_mpi_max())
-geom%global = supeq(maxdist,half*pi)
-
-! Get min/max lon/lat
-if (geom%global) then
-   geom%lon_min = -pi
-   geom%lon_max = pi
-   geom%lat_min = -half*pi
-   geom%lat_max = half*pi
+if (supeq(maxdist,half*pi)) then
+   ! Global domain
+   geom%grid_type = 'global'
+   geom%area = four*pi
+   geom%hull_mg%radius = mpl%msv%valr
 else
-   geom%lon_min = zss_minval(geom%lon_mga,geom%owned_mga(:,1))
-   geom%lon_max = zss_maxval(geom%lon_mga,geom%owned_mga(:,1))
-   geom%lat_min = zss_minval(geom%lat_mga,geom%owned_mga(:,1))
-   geom%lat_max = zss_maxval(geom%lat_mga,geom%owned_mga(:,1))
-   call mpl%f_comm%allreduce(geom%lon_min,fckit_mpi_min())
-   call mpl%f_comm%allreduce(geom%lon_max,fckit_mpi_max())
-   call mpl%f_comm%allreduce(geom%lat_min,fckit_mpi_min())
-   call mpl%f_comm%allreduce(geom%lat_max,fckit_mpi_max())
+   ! Regional domain
+   select case (afunctionspace%name())
+   case ('StructuredColumns')
+      ! StructuredColumns function space
+      geom%grid_type = 'regional_structuredcolumns'
+ 
+      ! Get structured columns function space
+      afunctionspace_sc = afunctionspace
+
+      ! Get structured grid
+      agrid_sc = afunctionspace_sc%grid()
+      aconfig_grid = agrid_sc%spec()
+
+      ! Get domain
+      if (.not.aconfig_grid%get("domain",aconfig_domain)) call mpl%abort('${subr}$','missing domain')
+      if (.not.aconfig_domain%get("type",domain_type)) call mpl%abort('${subr}$','missing domain type')
+      if (trim(domain_type)/="rectangular") call mpl%abort('${subr}$','only rectangular domains allowed')
+      if (.not.aconfig_domain%get("xmin",geom%xmin)) call mpl%abort('${subr}$','missing domain xmin')
+      if (.not.aconfig_domain%get("xmax",geom%xmax)) call mpl%abort('${subr}$','missing domain xmax')
+      if (.not.aconfig_domain%get("ymin",geom%ymin)) call mpl%abort('${subr}$','missing domain ymin')
+      if (.not.aconfig_domain%get("ymax",geom%ymax)) call mpl%abort('${subr}$','missing domain ymax')
+
+      ! Get projection
+      if (.not.aconfig_grid%get("projection",aconfig_proj)) call mpl%abort('${subr}$','missing projection')
+      geom%aproj = atlas_projection(aconfig_proj)
+
+      ! Get domain center
+      xcen = half*(geom%xmin+geom%xmax)
+      ycen = half*(geom%ymin+geom%ymax)
+      call geom%aproj%xy2lonlat(xcen,ycen,geom%lon_center,geom%lat_center)
+      geom%lon_center = geom%lon_center*deg2rad
+      geom%lat_center = geom%lat_center*deg2rad
+
+      ! Get grid size
+      ny = agrid_sc%ny()
+      nx_inf = agrid_sc%nx(1)
+      nx_sup = agrid_sc%nx(ny)
+      if (nx_inf/=nx_sup) call mpl%abort('${subr}$','unexpected grid shape')
+
+      ! Get corners coordinates
+      lonlat_bnd(:,1) = agrid_sc%lonlat(1,1)*deg2rad
+      lonlat_bnd(:,2) = agrid_sc%lonlat(nx_inf,1)*deg2rad
+      lonlat_bnd(:,3) = agrid_sc%lonlat(nx_sup,ny)*deg2rad
+      lonlat_bnd(:,4) = agrid_sc%lonlat(1,ny)*deg2rad
+   case ('NodeColumns')
+      ! NodeColumns function space
+      geom%grid_type = 'regional_nodecolumns'
+
+      ! Get node columns function space
+      afunctionspace_nc = afunctionspace
+
+      ! Get mesh
+      amesh = afunctionspace_nc%mesh()
+
+      ! Create node to cell connectivity
+      call atlas_build_node_to_cell_connectivity(amesh)
+
+      ! Get connectivity
+      aconnectivity = anodes%cell_connectivity()
+
+      ! Get ghost field
+      afield_ghost = anodes%ghost()
+      call afield_ghost%data(ghost)
+
+      ! Loop over nodes to find corners
+      ncorner = 0
+      do imga=1,aconnectivity%rows()
+         if ((ghost(imga)==0).and.(aconnectivity%cols(imga)==1)) then
+            ncorner = ncorner+1
+            imga_bnd(ncorner) = imga
+         end if
+      end do
+
+      ! Communication
+      call mpl%f_comm%allgather(ncorner,proc_to_ncorner)
+
+      ! Define corners coordinates
+      jcorner = 1
+      lonlat_bnd = zero
+      do iproc=1,mpl%nproc
+         do icorner=1,proc_to_ncorner(iproc)
+            if (iproc==mpl%myproc) then
+               lonlat_bnd(1,jcorner) = geom%lon_mga(imga_bnd(icorner))
+               lonlat_bnd(2,jcorner) = geom%lat_mga(imga_bnd(icorner))
+            end if
+            jcorner = jcorner+1
+         end do
+      end do
+      call mpl%f_comm%allreduce(lonlat_bnd,fckit_mpi_sum())
+   case default
+      call mpl%abort('${subr}$','wrong function space: '//afunctionspace%name())
+   end select
+
+   ! Enforce proper bounds
+   do ib=1,4
+      call lonlatmod(lonlat_bnd(1,ib),lonlat_bnd(2,ib))
+   end do
+
+   ! Transform to cartesian coordinates
+   do ib=1,4
+      call lonlat2xyz(mpl,lonlat_bnd(1,ib),lonlat_bnd(2,ib),vbnd(1,ib),vbnd(2,ib),vbnd(3,ib))
+   end do
+
+   if (geom%grid_type=='regional_nodecolumns') then
+      ! Get domain center
+      vbnd_cen = quarter*sum(vbnd,dim=2)
+      vbnd_cen = vbnd_cen/sqrt(sum(vbnd_cen**2))
+      call xyz2lonlat(mpl,vbnd_cen(1),vbnd_cen(2),vbnd_cen(3),geom%lon_center,geom%lat_center)
+   end if
+
+   ! Re-order corners to ensure the order of corners is circular
+   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,2),lonlat_bnd(2,2),dist_with_1(1))
+   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,3),lonlat_bnd(2,3),dist_with_1(2))
+   call sphere_dist(lonlat_bnd(1,1),lonlat_bnd(2,1),lonlat_bnd(1,4),lonlat_bnd(2,4),dist_with_1(3))
+   opposite_index = maxloc(dist_with_1)+1
+   if (opposite_index(1)/=3) then
+      ! Make sure oppsite corner is number 3
+      vtmp = vbnd(:,opposite_index(1))
+      vbnd(:,opposite_index(1)) = vbnd(:,3)
+      vbnd(:,3) = vtmp
+   end if
+   
+   ! Re-order corners to ensure the order of corners is positive
+   v1 = vbnd(:,2)-vbnd(:,1)
+   v2 = vbnd(:,3)-vbnd(:,1)
+   call vector_product(v1,v2,cp)
+   cd = (vbnd(:,1)+vbnd(:,2)+vbnd(:,3))/three
+   if (inf(sum(cp*cd),zero)) then
+      ! Switch corners 2 and 4
+      vtmp = vbnd(:,2)
+      vbnd(:,2) = vbnd(:,4)
+      vbnd(:,4) = vtmp
+   end if
+
+   ! Compute area as the sum of two spherical triangles
+   call area(vbnd(:,1),vbnd(:,2),vbnd(:,4),area_124)
+   call area(vbnd(:,2),vbnd(:,3),vbnd(:,4),area_234)
+   geom%area = area_124+area_234
+
+   ! Initialize domain hull
+   call geom%hull_mg%init(mpl,4,vbnd)
 end if
-geom%sin_lat_min = sin(geom%lat_min)
-geom%sin_lat_max = sin(geom%lat_max)
 
 ! Probe out
 @:probe_out()
@@ -666,7 +791,6 @@
 
 ! Local variables
 integer :: iproc,imga,ic0a,ic0,diff_grid,il0
-real(kind_real) :: xyz_ne(3),xyz_nw(3),xyz_se(3),xyz_sw(3),area_nw,area_se
 real(kind_real) :: norm_c0(geom%nl0),vert_coord_hor_c0(geom%nl0)
 
 ! Set name
@@ -710,7 +834,6 @@
 allocate(geom%c0a_to_mga(geom%nc0a))
 allocate(geom%lon_c0a(geom%nc0a))
 allocate(geom%lat_c0a(geom%nc0a))
-allocate(geom%area_c0a(geom%nc0a))
 allocate(geom%vert_coord_c0a(geom%nc0a,geom%nl0))
 allocate(geom%gmask_c0a(geom%nc0a,geom%nl0))
 allocate(geom%gmask_hor_c0a(geom%nc0a))
@@ -720,23 +843,6 @@
 allocate(geom%l0_to_l0i(geom%nl0))
 allocate(geom%l0i_to_l0(geom%nl0))
 
-! Default area
-if (.not.geom%area_provided) then
-   if (geom%global) then
-      ! Full sphere, equally distributed
-      geom%area_c0a = four*pi/real(geom%nc0,kind_real)
-   else
-      ! Limited Area Model, equally distributed
-      call lonlat2xyz(mpl,geom%lon_min,geom%lat_min,xyz_sw(1),xyz_sw(2),xyz_sw(3))
-      call lonlat2xyz(mpl,geom%lon_min,geom%lat_max,xyz_nw(1),xyz_nw(2),xyz_nw(3))
-      call lonlat2xyz(mpl,geom%lon_max,geom%lat_min,xyz_se(1),xyz_se(2),xyz_se(3))
-      call lonlat2xyz(mpl,geom%lon_max,geom%lat_max,xyz_ne(1),xyz_ne(2),xyz_ne(3))
-      call area(xyz_sw,xyz_nw,xyz_ne,area_nw)
-      call area(xyz_sw,xyz_ne,xyz_se,area_se)
-      geom%area_c0a = (area_nw+area_se)/real(geom%nc0,kind_real)
-   end if
-end if
-
 ! Subset Sc0 offset for halo A
 geom%proc_to_c0_offset(1) = 0
 do iproc=2,mpl%nproc
@@ -760,7 +866,6 @@
    ! Copy fields
    geom%lon_c0a = geom%lon_mga
    geom%lat_c0a = geom%lat_mga
-   if (geom%area_provided) geom%area_c0a = geom%area_mga
    geom%vert_coord_c0a = geom%vert_coord_mga
    geom%gmask_c0a = geom%gmask_mga
 else
@@ -769,7 +874,6 @@
       imga = geom%c0a_to_mga(ic0a)
       geom%lon_c0a(ic0a) = geom%lon_mga(imga)
       geom%lat_c0a(ic0a) = geom%lat_mga(imga)
-      if (geom%area_provided) geom%area_c0a(ic0a) = geom%area_mga(imga)
       geom%vert_coord_c0a(ic0a,:) = geom%vert_coord_mga(imga,:)
       geom%gmask_c0a(ic0a,:) = geom%gmask_mga(imga,:)
    end do
@@ -778,7 +882,6 @@
 ! Release memory
 deallocate(geom%lon_mga)
 deallocate(geom%lat_mga)
-if (geom%area_provided) deallocate(geom%area_mga)
 deallocate(geom%vert_coord_mga)
 
 ! Related fields
@@ -789,14 +892,14 @@
 end do
 call mpl%f_comm%allreduce(geom%nc0_gmask,fckit_mpi_sum())
 if (geom%nc0_gmask(0)>0) then
-   geom%area_max_c0 = zss_sum(geom%area_c0a,mask=geom%gmask_hor_c0a)
+   geom%area_max_c0 = geom%area*real(count(geom%gmask_hor_c0a),kind_real)/real(geom%nc0,kind_real)
 else
    geom%area_max_c0 = zero
 end if
 do il0=1,geom%nl0
    norm_c0(il0) = zss_count(geom%gmask_c0a(:,il0))
    if (norm_c0(il0)>0) then
-      geom%area_ver_c0(il0) = zss_sum(geom%area_c0a,mask=geom%gmask_c0a(:,il0))
+      geom%area_ver_c0(il0) = geom%area*real(count(geom%gmask_c0a(:,il0)),kind_real)/real(geom%nc0,kind_real)
       vert_coord_hor_c0(il0) = zss_sum(geom%vert_coord_c0a(:,il0),mask=geom%gmask_c0a(:,il0))
    else
       geom%area_ver_c0(il0) = zero
@@ -843,10 +946,9 @@
 integer :: iproc,ic0a,ic0u,ic0
 integer :: proc_to_universe_size(mpl%nproc)
 integer,allocatable :: order(:)
-real(kind_real) :: dist,lon_avg,lat_avg,distmax,norm_c0u
+real(kind_real) :: dist,lon_avg,lat_avg,distmax
 real(kind_real) :: xyz(3),xyz_avg(3)
 real(kind_real),allocatable :: proc_to_lon(:),proc_to_lat(:),proc_to_distmax(:)
-real(kind_real),allocatable :: area_c0u(:)
 
 ! Set name
 @:set_name(geom_setup_universe)
@@ -956,7 +1058,6 @@
 allocate(geom%c0u_to_c0(geom%nc0u))
 allocate(geom%lon_c0u(geom%nc0u))
 allocate(geom%lat_c0u(geom%nc0u))
-allocate(area_c0u(geom%nc0u))
 allocate(geom%vert_coord_c0u(geom%nc0u,geom%nl0))
 allocate(geom%gmask_c0u(geom%nc0u,geom%nl0))
 allocate(geom%gmask_hor_c0u(geom%nc0u))
@@ -984,19 +1085,10 @@
 ! Extend fields from halo A to universe on subset Sc0
 call geom%com_AU%ext(mpl,geom%lon_c0a,geom%lon_c0u)
 call geom%com_AU%ext(mpl,geom%lat_c0a,geom%lat_c0u)
-call geom%com_AU%ext(mpl,geom%area_c0a,area_c0u)
 call geom%com_AU%ext(mpl,geom%vert_coord_c0a,geom%vert_coord_c0u)
 call geom%com_AU%ext(mpl,geom%gmask_c0a,geom%gmask_c0u)
 if (geom%nc0u>0) geom%gmask_hor_c0u = any(geom%gmask_c0u,dim=2)
 
-! Related fields
-norm_c0u = zss_count(geom%gmask_hor_c0u)
-if (norm_c0u>0) then
-   geom%area_max_c0u = zss_sum(area_c0u,mask=geom%gmask_hor_c0u)
-else
-   geom%area_max_c0u = zero
-end if
-
 ! Check that Sc0 points in universe are not duplicated
 write(mpl%info,'(a7,a)') '','Check that Sc0 points in universe are not duplicated'
 call mpl%flush
@@ -1642,7 +1734,7 @@
 
 ! Local variables
 integer :: lnr
-real(kind_real) :: lon,lat
+real(kind_real) :: lon,lat,x,y
 logical :: valid
 
 ! Set name
@@ -1658,9 +1750,27 @@
 ! Loop
 do while (.not.valid)
    ! Generate random lon/lat
-   call rng%rand(geom%lon_min,geom%lon_max,lon)
-   call rng%rand(geom%sin_lat_min,geom%sin_lat_max,lat)
-   lat = asin(lat)
+   if (geom%grid_type=='global') then
+      call rng%rand(-pi,pi,lon)
+      call rng%rand(-one,one,lat)
+      lat = asin(lat)
+   elseif (geom%grid_type=='regional_structuredcolumns') then
+      call rng%rand(zero,one,x)
+      call rng%rand(zero,one,y)
+      x = geom%xmin+x*(geom%xmax-geom%xmin)
+      y = geom%ymin+y*(geom%ymax-geom%ymin)
+      call geom%aproj%xy2lonlat(x,y,lon,lat)
+      lon = lon*deg2rad
+      lat = lat*deg2rad
+   elseif (geom%grid_type=='regional_nodecolumns') then
+      ! Sub-optimal, but the projection is not available
+      do while (.not.valid)
+         call rng%rand(-pi,pi,lon)
+         call rng%rand(-one,one,lat)
+         lat = asin(lat)
+         call geom%hull_mg%inside(mpl,lon,lat,valid)
+      end do
+   end if
 
    ! Get index from lon/lat
    call geom%index_from_lonlat(mpl,lon,lat,il0,iproc,ic0a,valid)
@@ -1712,9 +1822,8 @@
 integer,allocatable :: proc_to_icxmin(:),ssa_to_cx(:),ssa_to_node(:),s_to_ssa(:),to_valid(:),order(:)
 integer,allocatable :: proc_to_nodemin(:),sa_to_s(:),order_s(:),cxa_to_node(:)
 integer,allocatable :: proc_to_nssa(:),ssa_to_ss(:),ss_to_cxa(:),ss_to_cx(:),ss_to_node(:)
-real(kind_real) :: nss_real,lonlat(2),valmin,xmin,ymin,zmin,chmin,dist,x_start,y_start,z_start,distmax,d,nn_dist(2),distmin
-real(kind_real) :: lon_start,lat_start
-real(kind_real),allocatable :: proc_to_xmin(:),proc_to_ymin(:),proc_to_zmin(:),proc_to_chmin(:)
+real(kind_real) :: lonlat(2),valmin,xmin,ymin,zmin,chmin,dist,x_start,y_start,z_start,distmax,d,nn_dist(2),distmin,x,y,distx,disty
+real(kind_real),allocatable :: rhc_cxa(:),proc_to_xmin(:),proc_to_ymin(:),proc_to_zmin(:),proc_to_chmin(:)
 real(kind_real),allocatable :: x_ssa(:),y_ssa(:),z_ssa(:),ch_ssa(:),potential(:),lon_sa(:),lat_sa(:),lon_s(:),lat_s(:)
 real(kind_real),allocatable :: lon_ssa(:),lat_ssa(:),rh_ssa(:),lon_rep(:),lat_rep(:),rh_rep(:),dist_rep(:)
 real(kind_real),allocatable :: x_ss(:),y_ss(:),z_ss(:),ch_ss(:),lon_ss(:),lat_ss(:),rh_ss(:)
@@ -1754,6 +1863,7 @@
    ! Allocation
    allocate(lmask_cxa(ncxa))
    allocate(cxa_to_node(ncxa))
+   allocate(rhc_cxa(ncxa))
 
    ! First step: decimate the grid
 
@@ -1764,6 +1874,21 @@
    write(mpl%test,trim(cfmt)) '','Decimate full grid, at least ',ns,' points required, '
    if (ifmt>0) call mpl%flush(newl=.false.)
 
+   ! Compute corrected length-scale
+   if ((geom%grid_type=='global').or.(geom%grid_type=='regional_nodecolumns')) then
+      rhc_cxa = rh_cxa
+   else
+      do icxa=1,ncxa
+         ! Compute distances to the boundaries
+         call geom%aproj%lonlat2xy(lon_cxa(icxa)*rad2deg,lat_cxa(icxa)*rad2deg,x,y)
+         distx = two*min(abs(x-geom%xmin),abs(x-geom%xmax))/(geom%xmax-geom%xmin)
+         disty = two*min(abs(y-geom%ymin),abs(y-geom%ymax))/(geom%ymax-geom%ymin)
+
+         ! Apply empirical factor
+         rhc_cxa(icxa) = rh_cxa(icxa)*(one-half*distx*disty)*(one+exp(-hundred*distx*disty))
+      end do
+   end if
+
    do while (retry)
       if (ncxa > 0) then
          ! Initialization
@@ -1773,15 +1898,12 @@
          ! Update nfac
          nfac = 2*nfac
 
-         ! Number of required points at global scale
-         nss_real = real(nfac*ns,kind_real)*four*pi/geom%area_max_c0*(one+repro_th)
-
-         if (geom%global) then
-            ! Global grid
-            call get_grid(mpl,floor(nss_real),agrid,nss)
-         else
-            ! Regional grid
-            call get_grid(mpl,nfac*ns,geom%lon_min,geom%lon_max,geom%lat_min,geom%lat_max,agrid,nss)
+         if ((geom%grid_type=='global').or.(geom%grid_type=='regional_nodecolumns')) then
+            ! Global grid or regional grid with NodeColumns function space (sub-optimal)
+            call get_grid(mpl,floor(real(nfac*ns,kind_real)*four*pi/geom%area_max_c0*(one+repro_th)),agrid,nss)
+         elseif (geom%grid_type=='regional_structuredcolumns') then
+            ! Regional grid, StructuredColumns function space
+            call get_grid(mpl,nfac*ns,geom%aproj,geom%lon_center,geom%lat_center,geom%xmin,geom%xmax,geom%ymin,geom%ymax,agrid,nss)
          end if
 
          ! Loop over grid points
@@ -1795,18 +1917,23 @@
                lonlat = agrid%lonlat(ix,iy)*deg2rad
                call lonlatmod(lonlat(1),lonlat(2))
 
-               ! Check if point is inside the hull
-               call hull_cxu%inside(mpl,lonlat(1),lonlat(2),valid)
+               ! Check if point is inside the domain hull
+               call geom%hull_mg%inside(mpl,lonlat(1),lonlat(2),valid)
 
                if (valid) then
-                  ! Find nearest neighbor in universe
-                  call tree_cxu%find_nearest_neighbors(mpl,lonlat(1),lonlat(2),1,nn_index(1:1))
-                  icxa = cxu_to_cxa(nn_index(1))
-
-                  ! Keep valid points on each processor
-                  if (mpl%msv%isnot(icxa)) then
-                     lmask_cxa(icxa) = mask_cxa(icxa)
-                     cxa_to_node(icxa) = inode
+                  ! Check if point is inside the universe hull
+                  call hull_cxu%inside(mpl,lonlat(1),lonlat(2),valid)
+
+                  if (valid) then
+                     ! Find nearest neighbor in universe
+                     call tree_cxu%find_nearest_neighbors(mpl,lonlat(1),lonlat(2),1,nn_index(1:1))
+                     icxa = cxu_to_cxa(nn_index(1))
+
+                     ! Keep valid points on each processor
+                     if (mpl%msv%isnot(icxa)) then
+                        lmask_cxa(icxa) = mask_cxa(icxa)
+                        cxa_to_node(icxa) = inode
+                     end if
                   end if
                end if
             end do
@@ -1857,11 +1984,11 @@
          ssa_to_node(issa) = cxa_to_node(icxa)
          if (method=='potential') then
             call lonlat2xyz(mpl,lon_cxa(icxa),lat_cxa(icxa),x_ssa(issa),y_ssa(issa),z_ssa(issa))
-            ch_ssa(issa) = two*sin(half*min(rh_cxa(icxa),pi))
+            ch_ssa(issa) = two*sin(half*min(rhc_cxa(icxa),pi))
          elseif (method=='maxrandom') then
             lon_ssa(issa) = lon_cxa(icxa)
             lat_ssa(issa) = lat_cxa(icxa)
-            rh_ssa(issa) = rh_cxa(icxa)
+            rh_ssa(issa) = rhc_cxa(icxa)
          end if
       end if
    end do
@@ -2015,14 +2142,14 @@
          end if
 
          ! Define starting point
-         if (geom%global) then
+         if (geom%grid_type=='global') then
+            ! Global grid
             x_start = zero
             y_start = zero
             z_start = one
          else
-            lon_start = half*(geom%lon_min+geom%lon_max)
-            lat_start = half*(geom%lat_min+geom%lat_max)
-            call lonlat2xyz(mpl,lon_start,lat_start,x_start,y_start,z_start)
+            ! Regional grid
+            call lonlat2xyz(mpl,geom%lon_center,geom%lat_center,x_start,y_start,z_start)
          end if
 
          ! Compute distance to the starting point
@@ -2396,6 +2523,7 @@
    end if
 
    ! Release memory
+   deallocate(rhc_cxa)
    deallocate(lmask_cxa)
    deallocate(cxa_to_node)
    deallocate(ssa_to_cx)
