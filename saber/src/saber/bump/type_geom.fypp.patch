--- /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/type_geom.fypp.tmp	2024-05-22 11:25:06.734616994 +0200
+++ /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/type_geom.fypp	2024-05-22 10:49:47.359275379 +0200
@@ -13,16 +13,17 @@
  & atlas_functionspace_structuredcolumns,atlas_mesh_nodes,atlas_structuredgrid
 use fckit_mpi_module, only: fckit_mpi_sum,fckit_mpi_min,fckit_mpi_max,fckit_mpi_status
 !$ use omp_lib
-use tools_atlas, only: get_grid,field_to_array,get_atlas_functionspace_size
+use tools_atlas, only: get_corners,get_grid,field_to_array,get_atlas_functionspace_size
 use tools_const, only: zero,quarter,half,one,two,four,hundred,pi,req,deg2rad,rad2deg,reqkm
-use tools_func, only: fletcher32,lonlatmod,grid_hash,independent_levels,sphere_dist,lonlat2xyz,xyz2lonlat,cart_dist,inside, &
- & vector_product,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_l2i,convert_i2l,zss_maxval,zss_minval,zss_sum,zss_count
+use tools_func, only: fletcher32,lonlatmod,grid_hash,independent_levels,sphere_dist,lonlat2xyz,xyz2lonlat,cart_dist, &
+ & vector_product,area,cx_to_cxa,cx_to_proc,cx_to_cxu,convert_l2i,convert_i2l,zss_maxval,zss_minval,zss_sum,zss_count
 use tools_kinds, only: kind_int,kind_real,huge_real,huge_int
 use tools_qsort, only: qsort
-use tools_repro, only: inf,sup,eq,infeq,indist,repro_th
-use tools_stripack, only: area
+use tools_repro, only: inf,sup,eq,infeq,supeq,indist,repro_th
+use type_bnda, only: bnda_type
 use type_com, only: com_type
 use type_fieldset, only: fieldset_type
+use type_hull, only: hull_type
 use type_io, only: io_type
 use type_linop, only: linop_type
 use type_mesh, only: mesh_type
@@ -41,14 +42,12 @@
 
    ! Input metadata
    logical,allocatable :: owned_mga(:,:)              !< Owned vs Halo/BC
-   logical :: area_provided                           !< Activated if areas are provided
    logical :: global                                  !< Global grid (regional if false)
 
    ! Geometry data on model grid, halo A
    integer :: nmga                                    !< Halo A size for model grid
    real(kind_real),allocatable :: lon_mga(:)          !< Longitudes
    real(kind_real),allocatable :: lat_mga(:)          !< Latitudes
-   real(kind_real),allocatable :: area_mga(:)         !< Areas
    real(kind_real),allocatable :: vert_coord_mga(:,:) !< Generalized vertical coordinate
    logical,allocatable :: gmask_mga(:,:)              !< Geometry mask
    type(atlas_functionspace) :: afunctionspace_mg     !< ATLAS function space of model grid
@@ -68,7 +67,6 @@
    logical :: same_grid                               !< Same grid and distribution flag
    real(kind_real),allocatable :: lon_c0a(:)          !< Longitudes
    real(kind_real),allocatable :: lat_c0a(:)          !< Latitudes
-   real(kind_real),allocatable :: area_c0a(:)         !< Area
    real(kind_real),allocatable :: vert_coord_c0a(:,:) !< Generalized vertical coordinate
    logical,allocatable :: gmask_c0a(:,:)              !< Geometry mask
    logical,allocatable :: gmask_hor_c0a(:)            !< Union of horizontal geometry masks
@@ -83,7 +81,6 @@
    logical,allocatable :: gmask_c0u(:,:)              !< Geometry mask
    logical,allocatable :: gmask_hor_c0u(:)            !< Union of horizontal geometry masks
    real(kind_real),allocatable :: mdist_c0u(:,:)      !< Minimum distance to mask
-   real(kind_real) :: area_max_c0u                    !< Area maximum on universe
 
    ! Geometry data on subset Sc0, global
    integer :: nc0                                     !< Number of subset Sc0 points
@@ -95,6 +92,7 @@
    real(kind_real) :: sin_lat_min                     !< Minimum latitude sinus
    real(kind_real) :: sin_lat_max                     !< Maximum latitude sinus
    integer,allocatable :: nc0_gmask(:)                !< Horizontal mask size on subset Sc0
+   real(kind_real) :: area                            !< Domain area
    real(kind_real),allocatable :: area_ver_c0(:)      !< Area profile on subset Sc0
    real(kind_real) :: area_max_c0                     !< Area maximum on subset Sc0
 
@@ -126,8 +124,11 @@
    ! Tree
    type(tree_type) :: tree_c0u                        !< Tree on subset Sc0, universe
 
-   ! Mesh
-   type(mesh_type) :: mesh_c0u                        !< Mesh on subset Sc0, universe
+   ! Boundaries
+   type(bnda_type) :: bnda_c0u                        !< Boundaries on subset Sc0, universe
+
+   ! Hull
+   type(hull_type) :: hull_c0u                        !< Domain hull on subset Sc0, universe
 
    ! Dirac fields for variables
    integer :: ndir                                    !< Number of valid Dirac points
@@ -141,7 +142,6 @@
 
    ! I/O
    type(io_type) :: io                                !< Subset Sc0 I/O
-   logical :: io_initialized                          !< Flag to check if subset Sc0 I/O is initialized
 
    ! Allocation flag
    logical :: allocated                               !< Allocation flag
@@ -152,7 +152,6 @@
    procedure :: from_atlas => geom_from_atlas
    procedure :: setup_universe => geom_setup_universe
    procedure :: setup_c0 => geom_setup_c0
-   procedure :: setup_mask_check => geom_setup_mask_check
    procedure :: geom_index_from_lonlat_r0
    procedure :: geom_index_from_lonlat_r1
    generic :: index_from_lonlat => geom_index_from_lonlat_r0,geom_index_from_lonlat_r1
@@ -218,7 +217,6 @@
 if (allocated(geom%il0rz)) deallocate(geom%il0rz)
 if (allocated(geom%lon_mga)) deallocate(geom%lon_mga)
 if (allocated(geom%lat_mga)) deallocate(geom%lat_mga)
-if (allocated(geom%area_mga)) deallocate(geom%area_mga)
 if (allocated(geom%vert_coord_mga)) deallocate(geom%vert_coord_mga)
 if (allocated(geom%myuniverse)) deallocate(geom%myuniverse)
 if (allocated(geom%proc_to_nc0a)) deallocate(geom%proc_to_nc0a)
@@ -244,7 +242,8 @@
 if (allocated(geom%disth)) deallocate(geom%disth)
 if (allocated(geom%as)) deallocate(geom%as)
 call geom%tree_c0u%dealloc
-call geom%mesh_c0u%dealloc
+call geom%bnda_c0u%dealloc
+call geom%hull_c0u%dealloc
 if (allocated(geom%londir)) deallocate(geom%londir)
 if (allocated(geom%latdir)) deallocate(geom%latdir)
 if (allocated(geom%iprocdir)) deallocate(geom%iprocdir)
@@ -282,7 +281,6 @@
 if (allocated(geom%c0a_to_mga)) deallocate(geom%c0a_to_mga)
 if (allocated(geom%lon_c0a)) deallocate(geom%lon_c0a)
 if (allocated(geom%lat_c0a)) deallocate(geom%lat_c0a)
-if (allocated(geom%area_c0a)) deallocate(geom%area_c0a)
 if (allocated(geom%vert_coord_c0a)) deallocate(geom%vert_coord_c0a)
 if (allocated(geom%gmask_c0a)) deallocate(geom%gmask_c0a)
 if (allocated(geom%l0_to_l0i)) deallocate(geom%l0_to_l0i)
@@ -312,6 +310,9 @@
 
 ! Local variables
 integer :: il0,jl0off,jl0r,jc3,jc4,iproc
+integer,allocatable :: order_c0(:),order_c0a(:)
+real(kind_real),allocatable :: lon_c0(:),lat_c0(:)
+type(mesh_type) :: mesh_c0u
 
 ! Set name
 @:set_name(geom_setup)
@@ -354,17 +355,24 @@
 ! Setup tree
 write(mpl%info,'(a7,a)') '','Setup tree'
 call mpl%flush
-call geom%tree_c0u%alloc(mpl,geom%nc0u)
-call geom%tree_c0u%init(geom%lon_c0u,geom%lat_c0u)
+call geom%tree_c0u%init(geom%nc0u,geom%lon_c0u,geom%lat_c0u)
 
-! Setup mesh
-write(mpl%info,'(a7,a)') '','Setup mesh'
+! Setup hull
+write(mpl%info,'(a7,a)') '','Setup hull'
 call mpl%flush
-call geom%mesh_c0u%alloc(geom%nc0u)
-call geom%mesh_c0u%init(mpl,rng,geom%lon_c0u,geom%lat_c0u,hull_bnd=.true.)
+if (geom%global) then
+   call geom%hull_c0u%init(mpl,geom%nc0u,geom%lon_c0u,geom%lat_c0u)
+else
+   call geom%hull_c0u%init(mpl,geom%afunctionspace_mg)
+end if
 
-! Setup mask boudaries checking fields
-call geom%setup_mask_check(mpl,nam)
+if (nam%mask_check) then
+   ! Setup boundaries
+   write(mpl%info,'(a7,a)') '','Setup boundaries'
+   call mpl%flush
+   call mesh_c0u%init(mpl,rng,geom%nc0u,geom%lon_c0u,geom%lat_c0u)
+   call geom%bnda_c0u%init(mpl,geom%nc0u,geom%nl0,geom%gmask_hor_c0u,geom%gmask_c0u,mesh_c0u)
+end if
 
 ! Setup horizontal distance
 write(mpl%info,'(a7,a)') '','Setup horizontal distance'
@@ -390,6 +398,37 @@
 ! Set allocation flag
 geom%allocated = .true.
 
+if (((nam%new_nicas.or.nam%load_nicas_local).and.nam%write_nicas_global).or.nam%load_nicas_global) then
+   ! Allocation
+   if (mpl%main) then
+      allocate(lon_c0(geom%nc0))
+      allocate(lat_c0(geom%nc0))
+      allocate(order_c0(geom%nc0))
+   else
+      allocate(lon_c0(0))
+      allocate(lat_c0(0))
+      allocate(order_c0(0))
+   end if
+   allocate(order_c0a(geom%nc0a))
+
+   ! Communication
+   call mpl%loc_to_glb(geom%nc0a,geom%nc0,geom%c0a_to_c0,geom%lon_c0a,lon_c0)
+   call mpl%loc_to_glb(geom%nc0a,geom%nc0,geom%c0a_to_c0,geom%lat_c0a,lat_c0)
+
+   ! Compute global order
+   if (mpl%main) call qsort(geom%nc0,lon_c0,lat_c0,order_c0,.false.)
+   call mpl%glb_to_loc(geom%nc0a,geom%nc0,geom%c0a_to_c0,order_c0,order_c0a)
+
+   ! Setup fields output
+   call geom%io%init(mpl,7,'0',geom%nc0,geom%nc0a,geom%c0a_to_c0,geom%proc_to_c0_offset,order_c0a)
+
+   ! Release memory
+   deallocate(lon_c0)
+   deallocate(lat_c0)
+   deallocate(order_c0)
+   deallocate(order_c0a)
+end if
+
 ! Print summary
 write(mpl%info,'(a7,a)') '','Geometry summary:'
 call mpl%flush
@@ -427,7 +466,7 @@
 end do
 
 ! Reset random seed if necessary
-call rng%reseed(mpl)
+call rng%reseed
 
 ! Probe out
 @:probe_out()
@@ -450,8 +489,8 @@
 type(fieldset_type),intent(in),optional :: fieldset    !< Fieldset
 
 ! Local variables
-integer :: il0,imga,ifield
-real(kind_real),allocatable :: area_mga(:,:)
+integer :: il0,imga
+real(kind_real) :: lon0,lat0,dist,maxdist
 real(kind_real),pointer :: real_ptr(:,:)
 type(atlas_field) :: afield,afield_lonlat
 type(atlas_functionspace_nodecolumns) :: afunctionspace_nc
@@ -483,7 +522,6 @@
 
 ! Default values
 geom%owned_mga = .true.
-geom%area_provided = .false.
 do il0=1,geom%nl0
    geom%vert_coord_mga(:,il0) = real(il0,kind_real)
 end do
@@ -497,18 +535,6 @@
       call afield%final()
    end if
 
-   ! Get area
-   if (fieldset%has_field('area')) then
-      afield = fieldset%field('area')
-      allocate(area_mga(geom%nmga,1))
-      call field_to_array(afield,mpl,area_mga)
-      allocate(geom%area_mga(geom%nmga))
-      geom%area_mga = area_mga(:,1)/req**2
-      deallocate(area_mga)
-      call afield%final()
-      geom%area_provided = .true.
-   end if
-
    ! Get vertical coordinate
    if (nam%vert_coord_name /= "") then
       afield = fieldset%field(nam%vert_coord_name)
@@ -569,15 +595,39 @@
    if (geom%owned_mga(imga,1)) call lonlatmod(geom%lon_mga(imga),geom%lat_mga(imga))
 end do
 
+! Get domain type
+if (mpl%main) then
+   lon0 = geom%lon_mga(1)
+   lat0 = geom%lat_mga(1)
+end if
+call mpl%f_comm%broadcast(lon0, mpl%rootproc-1)
+call mpl%f_comm%broadcast(lat0, mpl%rootproc-1)
+maxdist = zero
+do imga=1,geom%nmga
+   if (maxdist<pi) then
+      call sphere_dist(lon0,lat0,geom%lon_mga(imga),geom%lat_mga(imga),dist)
+      if (dist>maxdist) maxdist = dist
+   end if
+end do
+call mpl%f_comm%allreduce(maxdist,fckit_mpi_max())
+geom%global = supeq(maxdist,half*pi)
+
 ! Get min/max lon/lat
-geom%lon_min = zss_minval(geom%lon_mga,geom%owned_mga(:,1))
-geom%lon_max = zss_maxval(geom%lon_mga,geom%owned_mga(:,1))
-geom%lat_min = zss_minval(geom%lat_mga,geom%owned_mga(:,1))
-geom%lat_max = zss_maxval(geom%lat_mga,geom%owned_mga(:,1))
-call mpl%f_comm%allreduce(geom%lon_min,fckit_mpi_min())
-call mpl%f_comm%allreduce(geom%lon_max,fckit_mpi_max())
-call mpl%f_comm%allreduce(geom%lat_min,fckit_mpi_min())
-call mpl%f_comm%allreduce(geom%lat_max,fckit_mpi_max())
+if (geom%global) then
+   geom%lon_min = -pi
+   geom%lon_max = pi
+   geom%lat_min = -half*pi
+   geom%lat_max = half*pi
+else
+   geom%lon_min = zss_minval(geom%lon_mga,geom%owned_mga(:,1))
+   geom%lon_max = zss_maxval(geom%lon_mga,geom%owned_mga(:,1))
+   geom%lat_min = zss_minval(geom%lat_mga,geom%owned_mga(:,1))
+   geom%lat_max = zss_maxval(geom%lat_mga,geom%owned_mga(:,1))
+   call mpl%f_comm%allreduce(geom%lon_min,fckit_mpi_min())
+   call mpl%f_comm%allreduce(geom%lon_max,fckit_mpi_max())
+   call mpl%f_comm%allreduce(geom%lat_min,fckit_mpi_min())
+   call mpl%f_comm%allreduce(geom%lat_max,fckit_mpi_max())
+end if
 geom%sin_lat_min = sin(geom%lat_min)
 geom%sin_lat_max = sin(geom%lat_max)
 
@@ -600,8 +650,8 @@
 
 ! Local variables
 integer :: iproc,imga,ic0a,ic0,diff_grid,il0
-real(kind_real) :: xyz_ne(3),xyz_nw(3),xyz_se(3),xyz_sw(3),area_nw,area_se,area_total
-real(kind_real) :: norm_c0(geom%nl0),vert_coord_hor_c0(geom%nl0)
+real(kind_real) :: area_124,area_234
+real(kind_real) :: vbnd(3,4),norm_c0(geom%nl0),vert_coord_hor_c0(geom%nl0)
 
 ! Set name
 @:set_name(geom_setup_c0)
@@ -644,7 +694,6 @@
 allocate(geom%c0a_to_mga(geom%nc0a))
 allocate(geom%lon_c0a(geom%nc0a))
 allocate(geom%lat_c0a(geom%nc0a))
-allocate(geom%area_c0a(geom%nc0a))
 allocate(geom%vert_coord_c0a(geom%nc0a,geom%nl0))
 allocate(geom%gmask_c0a(geom%nc0a,geom%nl0))
 allocate(geom%gmask_hor_c0a(geom%nc0a))
@@ -654,22 +703,16 @@
 allocate(geom%l0_to_l0i(geom%nl0))
 allocate(geom%l0i_to_l0(geom%nl0))
 
-! Default area
-if (.not.geom%area_provided) then
-   if ((geom%lon_min<-0.9_kind_real*pi).and.(geom%lon_max>0.9_kind_real*pi) &
- & .and.(geom%lat_min<-0.45_kind_real*pi).and.(geom%lat_max>0.45_kind_real*pi)) then
-      ! Full sphere, equally distributed
-      geom%area_c0a = four*pi/real(geom%nc0,kind_real)
-   else
-      ! Limited Area Model, equally distributed
-      call lonlat2xyz(mpl,geom%lon_min,geom%lat_min,xyz_sw(1),xyz_sw(2),xyz_sw(3))
-      call lonlat2xyz(mpl,geom%lon_min,geom%lat_max,xyz_nw(1),xyz_nw(2),xyz_nw(3))
-      call lonlat2xyz(mpl,geom%lon_max,geom%lat_min,xyz_se(1),xyz_se(2),xyz_se(3))
-      call lonlat2xyz(mpl,geom%lon_max,geom%lat_max,xyz_ne(1),xyz_ne(2),xyz_ne(3))
-      call area(xyz_sw,xyz_nw,xyz_ne,area_nw)
-      call area(xyz_sw,xyz_ne,xyz_se,area_se)
-      geom%area_c0a = (area_nw+area_se)/real(geom%nc0,kind_real)
-   end if
+! Domain area
+if (geom%global) then
+   ! Full sphere
+   geom%area = four*pi
+else
+   ! Limited Area Model
+   call get_corners(mpl,geom%afunctionspace_mg,vbnd)
+   call area(vbnd(:,1),vbnd(:,2),vbnd(:,4),area_124)
+   call area(vbnd(:,2),vbnd(:,3),vbnd(:,4),area_234)
+   geom%area = area_124+area_234
 end if
 
 ! Subset Sc0 offset for halo A
@@ -695,7 +738,6 @@
    ! Copy fields
    geom%lon_c0a = geom%lon_mga
    geom%lat_c0a = geom%lat_mga
-   if (geom%area_provided) geom%area_c0a = geom%area_mga
    geom%vert_coord_c0a = geom%vert_coord_mga
    geom%gmask_c0a = geom%gmask_mga
 else
@@ -704,7 +746,6 @@
       imga = geom%c0a_to_mga(ic0a)
       geom%lon_c0a(ic0a) = geom%lon_mga(imga)
       geom%lat_c0a(ic0a) = geom%lat_mga(imga)
-      if (geom%area_provided) geom%area_c0a(ic0a) = geom%area_mga(imga)
       geom%vert_coord_c0a(ic0a,:) = geom%vert_coord_mga(imga,:)
       geom%gmask_c0a(ic0a,:) = geom%gmask_mga(imga,:)
    end do
@@ -713,7 +754,6 @@
 ! Release memory
 deallocate(geom%lon_mga)
 deallocate(geom%lat_mga)
-if (geom%area_provided) deallocate(geom%area_mga)
 deallocate(geom%vert_coord_mga)
 
 ! Related fields
@@ -724,14 +764,14 @@
 end do
 call mpl%f_comm%allreduce(geom%nc0_gmask,fckit_mpi_sum())
 if (geom%nc0_gmask(0)>0) then
-   geom%area_max_c0 = zss_sum(geom%area_c0a,mask=geom%gmask_hor_c0a)
+   geom%area_max_c0 = geom%area*real(count(geom%gmask_hor_c0a),kind_real)/real(geom%nc0,kind_real)
 else
    geom%area_max_c0 = zero
 end if
 do il0=1,geom%nl0
    norm_c0(il0) = zss_count(geom%gmask_c0a(:,il0))
    if (norm_c0(il0)>0) then
-      geom%area_ver_c0(il0) = zss_sum(geom%area_c0a,mask=geom%gmask_c0a(:,il0))
+      geom%area_ver_c0(il0) = geom%area*real(count(geom%gmask_c0a(:,il0)),kind_real)/real(geom%nc0,kind_real)       
       vert_coord_hor_c0(il0) = zss_sum(geom%vert_coord_c0a(:,il0),mask=geom%gmask_c0a(:,il0))
    else
       geom%area_ver_c0(il0) = zero
@@ -749,9 +789,6 @@
       geom%vert_coordavg(il0) = mpl%msv%valr
    end if
 end do
-area_total = zss_sum(geom%area_c0a)
-call mpl%f_comm%allreduce(area_total,fckit_mpi_sum())
-geom%global = (area_total>0.99_kind_real*four*pi)
 
 ! Compute independent levels
 write(mpl%test,'(a7,a)') '','Independent levels: '
@@ -778,12 +815,12 @@
 type(nam_type),intent(in) :: nam       !< Namelist
 
 ! Local variables
-integer :: iproc,ic0a,ic0u,ic0,notempty
+integer :: iproc,ic0a,ic0u,ic0
 integer :: proc_to_universe_size(mpl%nproc)
 integer,allocatable :: order(:)
-real(kind_real) :: dist,x,y,z,x_avg,y_avg,z_avg,n_avg,lon_avg,lat_avg,distmax,norm_c0u
+real(kind_real) :: dist,lon_avg,lat_avg,distmax
+real(kind_real) :: xyz(3),xyz_avg(3)
 real(kind_real),allocatable :: proc_to_lon(:),proc_to_lat(:),proc_to_distmax(:)
-real(kind_real),allocatable :: area_c0u(:)
 
 ! Set name
 @:set_name(geom_setup_universe)
@@ -807,28 +844,17 @@
    allocate(proc_to_distmax(mpl%nproc))
 
    ! Initialization
-   x_avg = zero
-   y_avg = zero
-   z_avg = zero
-   n_avg = zero
+   xyz_avg = zero
    distmax = zero
 
    ! Convert to cartesian coordinates and average
    do ic0a=1,geom%nc0a
-      call lonlat2xyz(mpl,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),x,y,z)
-      x_avg = x_avg+x
-      y_avg = y_avg+y
-      z_avg = z_avg+z
-      n_avg = n_avg+one
+      call lonlat2xyz(mpl,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),xyz(1),xyz(2),xyz(3))
+      xyz_avg = xyz_avg+xyz
    end do
-   if (n_avg>zero) then
-      ! Normalization
-      x_avg = x_avg/n_avg
-      y_avg = y_avg/n_avg
-      z_avg = z_avg/n_avg
-
+   if (any(abs(xyz_avg)>zero)) then
       ! Convert average back to lon/lat
-      call xyz2lonlat(mpl,x_avg,y_avg,z_avg,lon_avg,lat_avg)
+      call xyz2lonlat(mpl,xyz_avg(1),xyz_avg(2),xyz_avg(3),lon_avg,lat_avg)
 
       ! Compute maximum distance to average
       do ic0a=1,geom%nc0a
@@ -879,7 +905,7 @@
 end do
 
 ! Reset random seed if necessary
-call rng%reseed(mpl)
+call rng%reseed
 
 ! Communicate data from halo A to universe on subset Sc0
 write(mpl%info,'(a10,a)') '','Communicate data from halo A to universe on subset Sc0'
@@ -904,7 +930,6 @@
 allocate(geom%c0u_to_c0(geom%nc0u))
 allocate(geom%lon_c0u(geom%nc0u))
 allocate(geom%lat_c0u(geom%nc0u))
-allocate(area_c0u(geom%nc0u))
 allocate(geom%vert_coord_c0u(geom%nc0u,geom%nl0))
 allocate(geom%gmask_c0u(geom%nc0u,geom%nl0))
 allocate(geom%gmask_hor_c0u(geom%nc0u))
@@ -932,19 +957,10 @@
 ! Extend fields from halo A to universe on subset Sc0
 call geom%com_AU%ext(mpl,geom%lon_c0a,geom%lon_c0u)
 call geom%com_AU%ext(mpl,geom%lat_c0a,geom%lat_c0u)
-call geom%com_AU%ext(mpl,geom%area_c0a,area_c0u)
 call geom%com_AU%ext(mpl,geom%vert_coord_c0a,geom%vert_coord_c0u)
 call geom%com_AU%ext(mpl,geom%gmask_c0a,geom%gmask_c0u)
 if (geom%nc0u>0) geom%gmask_hor_c0u = any(geom%gmask_c0u,dim=2)
 
-! Related fields
-norm_c0u = zss_count(geom%gmask_hor_c0u)
-if (norm_c0u>0) then
-   geom%area_max_c0u = zss_sum(area_c0u,mask=geom%gmask_hor_c0u)
-else
-   geom%area_max_c0u = zero
-end if
-
 ! Check that Sc0 points in universe are not duplicated
 write(mpl%info,'(a7,a)') '','Check that Sc0 points in universe are not duplicated'
 call mpl%flush
@@ -963,81 +979,6 @@
 end subroutine geom_setup_universe
 
 !----------------------------------------------------------------------
-! Subroutine: geom_setup_mask_check
-!> Setup mask boundaries checking fields
-!----------------------------------------------------------------------
-subroutine geom_setup_mask_check(geom,mpl,nam)
-
-implicit none
-
-! Passed variables
-class(geom_type),intent(inout) :: geom !< Geometry
-type(mpl_type),intent(inout) :: mpl    !< MPI data
-type(nam_type),intent(in) :: nam       !< Namelist
-
-! Local variables
-integer :: il0,ibnda,nbndamax
-integer,allocatable :: bnda_to_c0u(:,:)
-real(kind_real) :: lon_arc(2),lat_arc(2),xbnda(2),ybnda(2),zbnda(2)
-
-! Set name
-@:set_name(geom_setup_mask_check)
-
-! Probe in
-@:probe_in()
-
-! Setup mask check
-if (nam%mask_check) then
-   write(mpl%info,'(a7,a)') '','Setup mask check'
-   call mpl%flush
-
-   ! Allocation
-   allocate(geom%mesh_c0u%nbnda(0:geom%nl0))
-
-   ! Count boundary arcs
-   do il0=0,geom%nl0
-      if (il0==0) then
-         call geom%mesh_c0u%count_bnda(geom%gmask_hor_c0u,geom%mesh_c0u%nbnda(il0))
-      else
-         call geom%mesh_c0u%count_bnda(geom%gmask_c0u(:,il0),geom%mesh_c0u%nbnda(il0))
-      end if
-   end do
-
-   ! Allocation
-   nbndamax = zss_maxval(geom%mesh_c0u%nbnda)
-   allocate(bnda_to_c0u(2,nbndamax))
-   allocate(geom%mesh_c0u%v1bnda(3,nbndamax,0:geom%nl0))
-   allocate(geom%mesh_c0u%v2bnda(3,nbndamax,0:geom%nl0))
-   allocate(geom%mesh_c0u%vabnda(3,nbndamax,0:geom%nl0))
-
-   do il0=0,geom%nl0
-      ! Get boundary arcs
-      if (il0==0) then
-         call geom%mesh_c0u%get_bnda(geom%gmask_hor_c0u,geom%mesh_c0u%nbnda(il0),bnda_to_c0u)
-      else
-         call geom%mesh_c0u%get_bnda(geom%gmask_c0u(:,il0),geom%mesh_c0u%nbnda(il0),bnda_to_c0u)
-      end if
-
-      ! Compute boundary arcs coordinates
-      do ibnda=1,geom%mesh_c0u%nbnda(il0)
-         lon_arc = geom%lon_c0u(bnda_to_c0u(:,ibnda))
-         lat_arc = geom%lat_c0u(bnda_to_c0u(:,ibnda))
-         call lonlat2xyz(mpl,lon_arc(1),lat_arc(1),xbnda(1),ybnda(1),zbnda(1))
-         call lonlat2xyz(mpl,lon_arc(2),lat_arc(2),xbnda(2),ybnda(2),zbnda(2))
-         geom%mesh_c0u%v1bnda(:,ibnda,il0) = (/xbnda(1),ybnda(1),zbnda(1)/)
-         geom%mesh_c0u%v2bnda(:,ibnda,il0) = (/xbnda(2),ybnda(2),zbnda(2)/)
-         call vector_product(geom%mesh_c0u%v1bnda(:,ibnda,il0),geom%mesh_c0u%v2bnda(:,ibnda,il0), &
- & geom%mesh_c0u%vabnda(:,ibnda,il0))
-      end do
-   end do
-end if
-
-! Probe out
-@:probe_out()
-
-end subroutine geom_setup_mask_check
-
-!----------------------------------------------------------------------
 ! Subroutine: geom_index_from_lonlat_r0
 !> Get nearest neighbor index from longitude/latitude/level, scalar
 !----------------------------------------------------------------------
@@ -1067,15 +1008,11 @@
 @:probe_in()
 
 ! Check if the point is inside the universe
-if (geom%mesh_c0u%n>0) then
-   call inside(mpl,geom%mesh_c0u%vbnd,lon,lat,valid)
-else
-   valid = .false.
-end if
+call geom%hull_c0u%inside(mpl,lon,lat,valid)
 
-if (valid) then
+if (valid.and.(geom%nc0u>0)) then
    ! Find nearest neighbor
-   call geom%tree_c0u%find_nearest_neighbors(lon,lat,1,nn_index,nn_dist)
+   call geom%tree_c0u%find_nearest_neighbors(mpl,lon,lat,1,nn_index,nn_dist)
    ic0 = geom%c0u_to_c0(nn_index(1))
    nn_proc = geom%c0_to_proc(ic0)
 else
@@ -1159,15 +1096,11 @@
 
 do i=1,n
    ! Check if the point is inside the universe
-   if (geom%mesh_c0u%n>0) then
-      call inside(mpl,geom%mesh_c0u%vbnd,lon(i),lat(i),valid(i))
-   else
-      valid(i) = .false.
-   end if
+   call geom%hull_c0u%inside(mpl,lon(i),lat(i),valid(i))
 
-   if (valid(i)) then
+   if (valid(i).and.(geom%nc0u>0)) then
       ! Find nearest neighbor
-      call geom%tree_c0u%find_nearest_neighbors(lon(i),lat(i),1,nn_index(i:i),nn_dist(i:i))
+      call geom%tree_c0u%find_nearest_neighbors(mpl,lon(i),lat(i),1,nn_index(i:i),nn_dist(i:i))
       ic0 = geom%c0u_to_c0(nn_index(i))
       nn_proc(i) = geom%c0_to_proc(ic0)
    else
@@ -1243,8 +1176,8 @@
 ! Local variables
 integer :: idir,il0,ic0a,idir_2d,ndir_2d,jl0
 integer :: il0dir(nam%ndir),iprocdir(nam%ndir),ic0adir(nam%ndir)
-integer,allocatable :: nn_index(:),distv(:),order(:,:),inbdir(:),idir_2dto3d(:)
-real(kind_real),allocatable :: londir_2d(:),latdir_2d(:)
+integer,allocatable :: nn_index(:),order(:,:),inbdir(:),idir_2dto3d(:)
+real(kind_real),allocatable :: distv(:),londir_2d(:),latdir_2d(:)
 logical :: valid(nam%ndir)
 type(tree_type) :: tree_dirac
 
@@ -1334,13 +1267,12 @@
             end if
          end do
 
-         ! Create tree
-         call tree_dirac%alloc(mpl,ndir_2d)
-         call tree_dirac%init(londir_2d,latdir_2d)
+         ! Setup tree
+         call tree_dirac%init(ndir_2d,londir_2d,latdir_2d)
 
          ! Affect each horizontal point to a dirac point
          do ic0a=1,geom%nc0a
-            call tree_dirac%find_nearest_neighbors(geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),ndir_2d,nn_index)
+            call tree_dirac%find_nearest_neighbors(mpl,geom%lon_c0a(ic0a),geom%lat_c0a(ic0a),ndir_2d,nn_index)
             geom%inbdir(ic0a,il0) = idir_2dto3d(nn_index(1))
          end do
 
@@ -1601,8 +1533,7 @@
    call fieldset%to_array(mpl,fld_mga)
 
    ! Model grid to subset Sc0
-   call geom_copy_mga_to_c0a_real_all(geom,mpl,nam,fld_c0a,fld_mga)
-   ! TODO: BUG, should be call geom%copy_mga_to_c0a(mpl,nam,fld_c0a,fld_mga)
+   call geom%copy_mga_to_c0a(mpl,nam,fld_c0a,fld_mga)
 end if
 
 ! Probe out
@@ -1715,7 +1646,7 @@
 !> Intialize sampling
 !----------------------------------------------------------------------
 subroutine geom_initialize_sampling(geom,mpl,rng,method,ncxa,lon_cxa,lat_cxa,mask_cxa,rh_cxa,cxa_to_cx,ncxu,cxu_to_cxa,tree_cxu, &
- & mesh_cxu,ifmt,ns,s_to_cx)
+ & hull_cxu,ifmt,ns,s_to_cx)
 
 implicit none
 
@@ -1733,7 +1664,7 @@
 integer,intent(in) :: ncxu                  !< Number of points (universe)
 integer,intent(in) :: cxu_to_cxa(ncxu)      !< Universe to local index
 type(tree_type),intent(in) :: tree_cxu      !< Universe KD-tree
-type(mesh_type),intent(in) :: mesh_cxu      !< Universe mesh
+type(hull_type),intent(in) :: hull_cxu      !< Universe hull
 integer,intent(in) :: ifmt                  !< Format indentation
 integer,intent(in) :: ns                    !< Number of samplings points (global)
 integer,intent(out) :: s_to_cx(ns)          !< Horizontal sampling index (global)
@@ -1746,13 +1677,13 @@
 integer,allocatable :: proc_to_nodemin(:),sa_to_s(:),order_s(:),cxa_to_node(:)
 integer,allocatable :: proc_to_nssa(:),ssa_to_ss(:),ss_to_cxa(:),ss_to_cx(:),ss_to_node(:)
 real(kind_real) :: nss_real,lonlat(2),valmin,xmin,ymin,zmin,chmin,dist,x_start,y_start,z_start,distmax,d,nn_dist(2),distmin
-!real(kind_real) :: lon_start,lat_start
+real(kind_real) :: lon_start,lat_start
 real(kind_real),allocatable :: proc_to_xmin(:),proc_to_ymin(:),proc_to_zmin(:),proc_to_chmin(:)
 real(kind_real),allocatable :: x_ssa(:),y_ssa(:),z_ssa(:),ch_ssa(:),potential(:),lon_sa(:),lat_sa(:),lon_s(:),lat_s(:)
 real(kind_real),allocatable :: lon_ssa(:),lat_ssa(:),rh_ssa(:),lon_rep(:),lat_rep(:),rh_rep(:),dist_rep(:)
 real(kind_real),allocatable :: x_ss(:),y_ss(:),z_ss(:),ch_ss(:),lon_ss(:),lat_ss(:),rh_ss(:)
 logical :: retry,valid
-logical,allocatable :: lmask_cxa(:),lmask_ssa(:),indist_ssa(:),gmask_s(:),lmask_ss(:),rmask(:)
+logical,allocatable :: lmask_cxa(:),lmask_ssa(:),indist_ssa(:),gmask_s(:),rmask(:)
 character(len=1024) :: cfmt
 type(atlas_structuredgrid) :: agrid
 type(tree_type) :: tree
@@ -1829,11 +1760,11 @@
                call lonlatmod(lonlat(1),lonlat(2))
 
                ! Check if point is inside the hull
-               call inside(mpl,mesh_cxu%vbnd,lonlat(1),lonlat(2),valid)
+               call hull_cxu%inside(mpl,lonlat(1),lonlat(2),valid)
 
                if (valid) then
                   ! Find nearest neighbor in universe
-                  call tree_cxu%find_nearest_neighbors(lonlat(1),lonlat(2),1,nn_index(1:1))
+                  call tree_cxu%find_nearest_neighbors(mpl,lonlat(1),lonlat(2),1,nn_index(1:1))
                   icxa = cxu_to_cxa(nn_index(1))
 
                   ! Keep valid points on each processor
@@ -2048,19 +1979,15 @@
          end if
 
          ! Define starting point
-         ! TODO: this is not correct, should be replaced later with the commented section
-         x_start = zero
-         y_start = zero
-         z_start = zero
-!         if (geom%global) then
-!            x_start = zero
-!            y_start = zero
-!            z_start = one
-!         else
-!            lon_start = half*(geom%lon_min+geom%lon_max)
-!            lat_start = half*(geom%lat_min+geom%lat_max)
-!            call lonlat2xyz(mpl,lon_start,lat_start,x_start,y_start,z_start)
-!         end if
+         if (geom%global) then
+            x_start = zero
+            y_start = zero
+            z_start = one
+         else
+            lon_start = half*(geom%lon_min+geom%lon_max)
+            lat_start = half*(geom%lat_min+geom%lat_max)
+            call lonlat2xyz(mpl,lon_start,lat_start,x_start,y_start,z_start)
+         end if
 
          ! Compute distance to the starting point
          is = 1
@@ -2273,13 +2200,8 @@
 
          ! Define sampling with a KD-tree
          do is=1,ns+nrep
-            if (is>2) then
-               ! Allocation
-               call tree%alloc(mpl,nssa,mask=lmask_ssa)
-
-               ! Initialization
-               call tree%init(lon_ssa,lat_ssa)
-            end if
+            ! Setup tree
+            if (is>2) call tree%init(nssa,lon_ssa,lat_ssa,lmask_ssa)
 
             ! Initialization
             distmax = zero
@@ -2305,7 +2227,7 @@
                      call sphere_dist(lon_ssa(ir),lat_ssa(ir),lon_ssa(nn_index(1)),lat_ssa(nn_index(1)),nn_dist(1))
                   else
                      ! Find nearest neighbor distance
-                     call tree%find_nearest_neighbors(lon_ssa(ir),lat_ssa(ir),1,nn_index(1:1),nn_dist(1:1))
+                     call tree%find_nearest_neighbors(mpl,lon_ssa(ir),lat_ssa(ir),1,nn_index(1:1),nn_dist(1:1))
                   end if
                   d = nn_dist(1)**2/(rh_ssa(ir)**2+rh_ssa(nn_index(1))**2)
 
@@ -2368,17 +2290,14 @@
 
             ! Remove closest points
             do irep=1,nrep
-               ! Allocation
-               call tree%alloc(mpl,ns+nrep,mask=rmask)
-
-               ! Initialization
-               call tree%init(lon_rep,lat_rep)
+               ! Setup tree
+               call tree%init(ns+nrep,lon_rep,lat_rep,rmask)
 
                ! Get minimum distance
                do is=1,ns+nrep
                   if (rmask(is)) then
                      ! Find nearest neighbor distance
-                     call tree%find_nearest_neighbors(lon_rep(is),lat_rep(is),2,nn_index,nn_dist)
+                     call tree%find_nearest_neighbors(mpl,lon_rep(is),lat_rep(is),2,nn_index,nn_dist)
                      if (nn_index(1)==is) then
                         dist_rep(is) = nn_dist(2)
                      elseif (nn_index(2)==is) then
@@ -2561,7 +2480,7 @@
 call rng%desync(mpl)
 
 ! Reset random seed if necessary
-call rng%reseed(mpl)
+call rng%reseed
 
 ! Probe out
 @:probe_out()
