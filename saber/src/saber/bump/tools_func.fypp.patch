--- /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/tools_func.fypp.tmp	2024-05-22 11:25:06.666616875 +0200
+++ /home/benjaminm/code/oops-bundle/ecsaber/saber/src/saber/bump/tools_func.fypp	2024-05-22 10:49:45.923273119 +0200
@@ -66,8 +66,8 @@
 interface det
    module procedure func_det
 end interface
-interface inside
-   module procedure func_inside
+interface area
+   module procedure func_area
 end interface
 interface add
    module procedure func_add
@@ -148,7 +148,7 @@
 
 private
 public :: fletcher32,lonlatmod,rad2short,grid_hash,independent_levels,sphere_bearing,sphere_dist,cart_dist,lonlat2xyz,xyz2lonlat, &
- & vector_product,det,inside,add,divide,vert_interp_size,vert_interp_setup,vert_interp,cholesky,syminv,histogram, &
+ & vector_product,det,area,add,divide,vert_interp_size,vert_interp_setup,vert_interp,cholesky,syminv,histogram, &
  & cx_to_cxa,cx_to_proc,cx_to_cxu,convert_i2l,convert_l2i,zss_maxval,zss_minval,zss_sum,zss_count,global_average
 
 contains
@@ -585,6 +585,9 @@
 real(kind_real),intent(out) :: lon !< Longitude [radians]
 real(kind_real),intent(out) :: lat !< Latitude [radians]
 
+! Local variables
+real(kind_real) :: r,xn,yn,zn
+
 ! Set name
 @:set_name(func_xyz2lonlat)
 
@@ -592,12 +595,24 @@
 @:probe_in()
 
 if (mpl%msv%isnot(x).and.mpl%msv%isnot(y).and.mpl%msv%isnot(z)) then
-   ! Convert to lon/lat
-   call ageometry%xyz2lonlat(x,y,z,lon,lat)
-
-   ! Copy coordinates
-   lon = lon*deg2rad
-   lat = lat*deg2rad
+   ! Normalize x,y,z
+   r = sqrt(x**2+y**2+z**2)
+   if (r>zero) then
+      xn = x/r
+      yn = y/r
+      zn = z/r
+
+      ! Convert to lon/lat
+      call ageometry%xyz2lonlat(xn,yn,zn,lon,lat)
+
+      ! Copy coordinates
+      lon = lon*deg2rad
+      lat = lat*deg2rad
+   else
+      ! Missing values
+      lon = mpl%msv%valr
+      lat = mpl%msv%valr
+   end if
 else
    ! Missing values
    lon = mpl%msv%valr
@@ -689,63 +704,90 @@
 end subroutine func_det
 
 !----------------------------------------------------------------------
-! Subroutine: func_inside
-!> Find whether a point is inside the hull boundaries or not
+! Subroutine: func_area
+!> Compute the area of a spherical triangle
+! Source: https://people.sc.fsu.edu/~jburkardt/f_src/stripack/stripack.html
+! Author: Robert Renka
+! Original licensing: none
+! Modified by Benjamin Menetrier for BUMP
+! Licensing: this code is distributed under the CeCILL-C license
+! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
 !----------------------------------------------------------------------
-subroutine func_inside(mpl,vbnd,lon,lat,inside_hull)
+subroutine func_area(v1,v2,v3,area)
 
 implicit none
 
 ! Passed variables
-type(mpl_type),intent(inout) :: mpl     !< MPI data
-real(kind_real),intent(in) :: vbnd(:,:) !< Boundary coordinates
-real(kind_real),intent(in) :: lon       !< Longitude
-real(kind_real),intent(in) :: lat       !< Latitude
-logical,intent(out) :: inside_hull      !< True if the point is inside the hull
+real(kind_real),intent(in) :: v1(3) !< First point cartesian coordinates
+real(kind_real),intent(in) :: v2(3) !< Second point cartesian coordinates
+real(kind_real),intent(in) :: v3(3) !< Third point cartesian coordinates
+real(kind_real),intent(out) :: area !< Area on the unit sphere
 
 ! Local variables
-integer :: i,inext
-real(kind_real) :: vp(3),v1(3),v2(3),cp(3),cd(3)
+real(kind_real) :: a1,a2,a3,ca1,ca2,ca3,s12,s23,s31
+real(kind_real) :: dv1(3),dv2(3),dv3(3),u12(3),u23(3),u31(3)
 
 ! Set name
-@:set_name(func_inside)
+@:set_name(func_area)
 
 ! Probe in
 @:probe_in()
 
-! Transform to cartesian coordinates
-call lonlat2xyz(mpl,lon,lat,vp(1),vp(2),vp(3))
-
 ! Initialization
-inside_hull = .true.
-
-do i=1,size(vbnd,2)
-   ! Index
-   if (i<size(vbnd,2)) then
-      inext = i+1
-   else
-      inext = 1
-   end if
-
-   ! Cross-product
-   v1 = vbnd(:,inext)-vbnd(:,i)
-   v2 = vp-vbnd(:,i)
-   call vector_product(v1,v2,cp)
-
-   ! Centroid
-   cd = (vp+vbnd(:,i)+vbnd(:,inext))/three
-
-   ! Compare the directions
-   if (inf(sum(cp*cd),zero)) then
-      inside_hull = .false.
-      exit
-   end if
-end do
+dv1 = v1
+dv2 = v2
+dv3 = v3
+
+! Compute cross products Uij = Vi X Vj
+u12(1) = dv1(2)*dv2(3)-dv1(3)*dv2(2)
+u12(2) = dv1(3)*dv2(1)-dv1(1)*dv2(3)
+u12(3) = dv1(1)*dv2(2)-dv1(2)*dv2(1)
+u23(1) = dv2(2)*dv3(3)-dv2(3)*dv3(2)
+u23(2) = dv2(3)*dv3(1)-dv2(1)*dv3(3)
+u23(3) = dv2(1)*dv3(2)-dv2(2)*dv3(1)
+u31(1) = dv3(2)*dv1(3)-dv3(3)*dv1(2)
+u31(2) = dv3(3)*dv1(1)-dv3(1)*dv1(3)
+u31(3) = dv3(1)*dv1(2)-dv3(2)*dv1(1)
+
+! Normalize Uij to unit vectors
+s12 = dot_product(u12,u12)
+s23 = dot_product(u23,u23)
+s31 = dot_product(u31,u31)
+
+! Test for a degenerate triangle associated with collinear vertices
+if ((.not.(abs(s12)>zero)).or.(.not.(abs(s23)>zero)).or.(.not.(abs(s31)>zero))) then
+   area = zero
+else
+   s12 = sqrt(s12)
+   s23 = sqrt(s23)
+   s31 = sqrt(s31)
+   u12 = u12/s12
+   u23 = u23/s23
+   u31 = u31/s31
+
+   ! Compute interior angles Ai as the dihedral angles between planes
+   ca1 = -dot_product(u12,u31)
+   ca2 = -dot_product(u23,u12)
+   ca3 = -dot_product(u31,u23)
+   ca1 = max(ca1,-one)
+   ca1 = min(ca1,+one)
+   ca2 = max(ca2,-one)
+   ca2 = min(ca2,+one)
+   ca3 = max(ca3,-one)
+   ca3 = min(ca3,+one)
+   a1 = acos(ca1)
+   a2 = acos(ca2)
+   a3 = acos(ca3)
+
+   ! Compute area = a1 + a2 + a3 - pi
+   area = a1+a2+a3-pi
+   if (area<zero) area = zero
+end if
 
 ! Probe out
 @:probe_out()
 
-end subroutine func_inside
+end subroutine func_area
 
 !----------------------------------------------------------------------
 ! Subroutine: func_add
