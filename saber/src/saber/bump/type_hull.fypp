#:include 'instrumentation.fypp'
!----------------------------------------------------------------------
! Module: type_hull
!> Hull derived type
! Author: Benjamin Menetrier
! Licensing: this code is distributed under the CeCILL-C license
! Copyright 2015-... UCAR, CERFACS, METEO-FRANCE and IRIT
!----------------------------------------------------------------------
module type_hull

use tools_const, only: zero,four,pi
use tools_func, only: lonlat2xyz,vector_product,area
use tools_kinds, only: kind_real,huge_real
use tools_repro, only: sup,repro_th
use type_mpl, only: mpl_type
@:use_probe()

implicit none

! Hull derived type
type hull_type
   integer :: nb                            !< Number of hull vertices
   real(kind_real),allocatable :: vbnd(:,:) !< Hull vertices
   real(kind_real) :: area                  !< Hull area
contains
   procedure :: hull_init_empty
   procedure :: hull_init_from_vertices
   generic :: init => hull_init_empty,hull_init_from_vertices
   procedure :: dealloc => hull_dealloc
   procedure :: inside => hull_inside
   procedure :: distance => hull_distance
end type hull_type

private
public :: hull_type

contains

!----------------------------------------------------------------------
! Subroutine: hull_init_empty
!> Allocation and initialization of empty hull
!----------------------------------------------------------------------
subroutine hull_init_empty(hull)

implicit none

! Passed variables
class(hull_type),intent(inout) :: hull  !< Hull

! Set name
@:set_name(hull_init_empty)

! Probe in
@:probe_in()

! No hull vertices
hull%nb = 0

! Allocation
allocate(hull%vbnd(3,hull%nb))

! Whole sphere
hull%area = four*pi

! Probe out
@:probe_out()

end subroutine hull_init_empty

!----------------------------------------------------------------------
! Subroutine: hull_init_from_vertices
!> Allocation and initialization of hull from vertices
!----------------------------------------------------------------------
subroutine hull_init_from_vertices(hull,mpl,n,vbnd)

implicit none

! Passed variables
class(hull_type),intent(inout) :: hull  !< Hull
type(mpl_type),intent(inout) :: mpl     !< MPI data
integer,intent(in) :: n                 !< Size
real(kind_real),intent(in) :: vbnd(3,n) !< Hull vertices

! Local variables
integer :: ib,ibnext
real(kind_real) :: triangle_area
real(kind_real) :: cd(3)

! Set name
@:set_name(hull_init_from_vertices)

! Probe in
@:probe_in()

! Copy number of hull vertices
hull%nb = n

! Allocation
allocate(hull%vbnd(3,hull%nb))

if (hull%nb>0) then
   ! Copy
   hull%vbnd = vbnd

   ! Centroid
   cd = sum(vbnd,dim=2)
   cd = cd/sqrt(sum(cd**2))

   ! Compute area
   hull%area = zero
   do ib=1,hull%nb
      ! Index
      if (ib<hull%nb) then
         ibnext = ib+1
      else
         ibnext = 1
      end if

      ! Add triangle area
      call area(cd,hull%vbnd(:,ib),hull%vbnd(:,ibnext),triangle_area)
      hull%area = hull%area+triangle_area
   end do
else
   ! Whole sphere
   hull%area = four*pi
end if

! Probe out
@:probe_out()

end subroutine hull_init_from_vertices

!----------------------------------------------------------------------
! Subroutine: hull_dealloc
!> Release memory
!----------------------------------------------------------------------
subroutine hull_dealloc(hull)

implicit none

! Passed variables
class(hull_type),intent(inout) :: hull !< Hull

! Set name
@:set_name(hull_dealloc)

! Probe in
@:probe_in()

! Release memory
if (allocated(hull%vbnd)) deallocate(hull%vbnd)

! Probe out
@:probe_out()

end subroutine hull_dealloc

!----------------------------------------------------------------------
! Subroutine: hull_inside
!> Find whether a point is inside the hull or not
!----------------------------------------------------------------------
subroutine hull_inside(hull,mpl,lon,lat,inside_hull)

implicit none

! Passed variables
class(hull_type),intent(in) :: hull !< Hull
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: lon   !< Longitude
real(kind_real),intent(in) :: lat   !< Latitude
logical,intent(out) :: inside_hull  !< True if the point is inside the hull

! Local variables
integer :: ib,ibnext
real(kind_real) :: vp(3),v1(3),v2(3),cp(3),cd(3)

! Set name
@:set_name(hull_inside)

! Probe in
@:probe_in()

if (allocated(hull%vbnd)) then
   ! Transform to cartesian coordinates
   call lonlat2xyz(mpl,lon,lat,vp(1),vp(2),vp(3))

   ! Initialization
   inside_hull = .true.

   do ib=1,hull%nb
      ! Index
      if (ib<hull%nb) then
         ibnext = ib+1
      else
         ibnext = 1
      end if

      ! Check whether points are aligned
      call vector_product(hull%vbnd(:,ib),hull%vbnd(:,ibnext),cp)
      cp = cp/sqrt(sum(cp**2))

      if (sup(abs(sum(vp*cp)),repro_th)) then
         ! Points are not aligned (aligned or almost aligned points are considered inside the hull)

         ! Cross-product
         v1 = hull%vbnd(:,ibnext)-hull%vbnd(:,ib)
         v2 = vp-hull%vbnd(:,ib)
         call vector_product(v1,v2,cp)

         ! Centroid
         cd = vp+hull%vbnd(:,ib)+hull%vbnd(:,ibnext)
         cd = cd/sqrt(sum(cd**2))

         ! Compare the directions
         if (sum(cp*cd)<zero) then
            inside_hull = .false.
            exit
         end if
      end if
   end do
else
   ! Empty universe
   inside_hull = .false.
end if

! Probe out
@:probe_out()

end subroutine hull_inside

!----------------------------------------------------------------------
! Subroutine: hull_distance
!> Find minimum distance to the hull
!----------------------------------------------------------------------
subroutine hull_distance(hull,mpl,lon,lat,dist)

implicit none

! Passed variables
class(hull_type),intent(in) :: hull !< Hull
type(mpl_type),intent(inout) :: mpl !< MPI data
real(kind_real),intent(in) :: lon   !< Longitude
real(kind_real),intent(in) :: lat   !< Latitude
real(kind_real),intent(out) :: dist !< Distance to the hull

! Local variables
integer :: ib,ibnext
real(kind_real) :: dist_test
real(kind_real) :: vp(3),cp(3)

! Set name
@:set_name(hull_distance)

! Probe in
@:probe_in()

if (allocated(hull%vbnd)) then
   ! Transform to cartesian coordinates
   call lonlat2xyz(mpl,lon,lat,vp(1),vp(2),vp(3))

   ! Initialization
   dist = huge_real

   do ib=1,hull%nb
      ! Index
      if (ib<hull%nb) then
         ibnext = ib+1
      else
         ibnext = 1
      end if

      if ((sum(abs(hull%vbnd(:,ib)-vp))<repro_th).or.(sum(abs(hull%vbnd(:,ibnext)-vp))<repro_th)) then
         ! Point from the hull
         dist = zero
         exit
      else
         ! Distance to the arc
         call vector_product(hull%vbnd(:,ib),hull%vbnd(:,ibnext),cp)
         cp = cp/sqrt(sum(cp**2))
         dist_test = asin(sum(vp*cp))
         if (dist_test<zero) then
            call mpl%abort('${subr}$','point shoud be inside hull to compute distance')
         else
            dist = min(dist,dist_test)
         end if
      end if
   end do
else
   ! Missing value
   dist = mpl%msv%valr
end if

! Probe out
@:probe_out()

end subroutine hull_distance

end module type_hull

