--- /home/benjaminm/code/oops-bundle/ecsaber/saber/quench/src/Fields.cc.tmp.bak	2024-07-10 17:22:27.208365262 +0200
+++ /home/benjaminm/code/oops-bundle/ecsaber/saber/quench/src/Fields.cc	2024-07-10 11:22:03.109429068 +0200
@@ -23,48 +23,67 @@
 #include "atlas/util/Point.h"
 
 #include "eckit/config/Configuration.h"
+#include "eckit/exception/Exceptions.h"
 #include "eckit/mpi/Comm.h"
 
-#include "oops/util/abor1_cpp.h"
 #include "oops/util/FieldSetHelpers.h"
 #include "oops/util/FieldSetOperations.h"
 #include "oops/util/Logger.h"
 #include "oops/util/Random.h"
 
+#include "src/FieldsIOBase.h"
 #include "src/Geometry.h"
 
-#include "saber/interpolation/AtlasInterpWrapper.h"
+namespace quench {
 
 // -----------------------------------------------------------------------------
-namespace quench {
+
+static std::vector<quench::Interpolation> interpolations_;
+
 // -----------------------------------------------------------------------------
-Fields::Fields(const Geometry & geom, const Variables & vars,
-               const util::DateTime & time):
-  geom_(new Geometry(geom)), vars_(vars), time_(time)
-{
-  oops::Log::trace() << "Fields::Fields starting" << std::endl;
+
+std::vector<quench::Interpolation>& Fields::interpolations() {
+  return interpolations_;
+}
+
+// -----------------------------------------------------------------------------
+
+Fields::Fields(const Geometry & geom,
+               const Variables & vars,
+               const util::DateTime & time)
+  : geom_(new Geometry(geom)), vars_(vars), time_(time) {
+  oops::Log::trace() << classname() << "::Fields starting" << std::endl;
 
   // Reset ATLAS fieldset
   fset_ = atlas::FieldSet();
 
   for (auto & var : vars_) {
+    // Set number of levels
     var.setLevels(geom_->levels(var.name()));
+
     // Create field
     atlas::Field field = geom_->functionSpace().createField<double>(
       atlas::option::name(var.name()) | atlas::option::levels(var.getLevels()));
     fset_.add(field);
   }
 
+  // Set interpolation type
+  for (auto field : fset_) {
+    field.metadata().set("interp_type", "default");
+  }
+
   // Set fields to zero
   this->zero();
 
-  oops::Log::trace() << "Fields::Fields done" << std::endl;
+  oops::Log::trace() << classname() << "::Fields done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
-Fields::Fields(const Fields & other, const Geometry & geom):
-  geom_(new Geometry(geom)), vars_(other.vars_), time_(other.time_)
-{
-  oops::Log::trace() << "Fields::Fields starting" << std::endl;
+
+Fields::Fields(const Fields & other,
+               const Geometry & geom)
+  : geom_(new Geometry(geom)), vars_(other.vars_), time_(other.time_) {
+  oops::Log::trace() << classname() << "::Fields starting" << std::endl;
 
   // Reset ATLAS fieldset
   fset_ = atlas::FieldSet();
@@ -72,7 +91,8 @@
   // Check number of levels
   for (const auto & var : vars_) {
     if (geom_->levels(var.name()) != geom.levels(var.name())) {
-      ABORT("different number of levels for variable " + var.name() + ", cannot interpolate");
+      throw eckit::Exception("Different number of levels for variable " + var.name()
+        + ", cannot interpolate", Here());
     }
   }
 
@@ -80,6 +100,9 @@
     // Copy fieldset
     fset_ = util::copyFieldSet(other.fset_);
   } else {
+    // Setup interpolation
+    const auto & interpolation = setupGridInterpolation(*other.geom_);
+
     // Create fieldset
     for (const auto & var : vars_) {
       atlas::Field field = geom_->functionSpace().createField<double>(
@@ -87,19 +110,27 @@
       fset_.add(field);
     }
 
-    // Interpolate
-    saber::interpolation::AtlasInterpWrapper interp(other.geom_->partitioner(),
-      other.geom_->functionSpace(), geom.grid(), geom.functionSpace());
-    interp.execute(other.fset_, fset_);
+    // Set interpolation type
+    for (auto field : fset_) {
+      field.metadata().set("interp_type", "default");
+    }
+
+    // Copy fieldset
+    atlas::FieldSet fset = util::copyFieldSet(other.fset_);
+
+    // Horizontal interpolation
+    interpolation->execute(fset, fset_);
   }
 
-  oops::Log::trace() << "Fields::Fields done" << std::endl;
+  oops::Log::trace() << classname() << "::Fields done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
-Fields::Fields(const Fields & other, const bool copy):
-  geom_(other.geom_), vars_(other.vars_), time_(other.time_)
-{
-  oops::Log::trace() << "Fields::Fields starting" << std::endl;
+
+Fields::Fields(const Fields & other,
+               const bool copy)
+  : geom_(other.geom_), vars_(other.vars_), time_(other.time_) {
+  oops::Log::trace() << classname() << "::Fields starting" << std::endl;
 
   // Reset ATLAS fieldset
   fset_ = atlas::FieldSet();
@@ -111,6 +142,11 @@
     fset_.add(field);
   }
 
+  // Set interpolation type
+  for (auto field : fset_) {
+    field.metadata().set("interp_type", "default");
+  }
+
   // Set fields to zero
   this->zero();
 
@@ -118,10 +154,10 @@
   if (copy) {
     for (const auto & var : vars_) {
       atlas::Field field = fset_[var.name()];
-      atlas::Field fieldOther = other.fset_[var.name()];
+      const atlas::Field fieldOther = other.fset_[var.name()];
       if (field.rank() == 2) {
         auto view = atlas::array::make_view<double, 2>(field);
-        auto viewOther = atlas::array::make_view<double, 2>(fieldOther);
+        const auto viewOther = atlas::array::make_view<double, 2>(fieldOther);
         for (atlas::idx_t jnode = 0; jnode < field.shape(0); ++jnode) {
           for (atlas::idx_t jlevel = 0; jlevel < field.shape(1); ++jlevel) {
             view(jnode, jlevel) = viewOther(jnode, jlevel);
@@ -130,13 +166,16 @@
       }
     }
   }
-  oops::Log::trace() << "Fields::Fields done" << std::endl;
+
+  oops::Log::trace() << classname() << "::Fields done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
-Fields::Fields(const Fields & other):
-  geom_(other.geom_), vars_(other.vars_), time_(other.time_)
-{
-  oops::Log::trace() << "Fields::Fields(const Fields & other) starting" << std::endl;
+
+Fields::Fields(const Fields & other)
+  : geom_(other.geom_), vars_(other.vars_), time_(other.time_) {
+  oops::Log::trace() << classname() << "::Fields starting" << std::endl;
+
   // Reset ATLAS fieldset
   fset_ = atlas::FieldSet();
 
@@ -145,10 +184,10 @@
     // Create field
     atlas::Field field = geom_->functionSpace().createField<double>(
       atlas::option::name(var.name()) | atlas::option::levels(var.getLevels()));
-    atlas::Field fieldOther = other.fset_[var.name()];
+    const atlas::Field fieldOther = other.fset_[var.name()];
     if (field.rank() == 2) {
       auto view = atlas::array::make_view<double, 2>(field);
-      auto viewOther = atlas::array::make_view<double, 2>(fieldOther);
+      const auto viewOther = atlas::array::make_view<double, 2>(fieldOther);
       for (atlas::idx_t jnode = 0; jnode < field.shape(0); ++jnode) {
         for (atlas::idx_t jlevel = 0; jlevel < field.shape(1); ++jlevel) {
           view(jnode, jlevel) = viewOther(jnode, jlevel);
@@ -157,11 +196,20 @@
     }
     fset_.add(field);
   }
-  oops::Log::trace() << "Fields::Fields(const Fields & other) done" << std::endl;
+
+  // Set interpolation type
+  for (auto field : fset_) {
+    field.metadata().set("interp_type", "default");
+  }
+
+  oops::Log::trace() << classname() << "::Fields done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::zero() {
-  oops::Log::trace() << "Fields::zero starting" << std::endl;
+  oops::Log::trace() << classname() << "::zero starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     if (field.rank() == 2) {
@@ -170,11 +218,15 @@
     }
   }
   fset_.set_dirty(false);
+
   oops::Log::trace() << "Fields::zero end" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::constantValue(const double & value) {
-  oops::Log::trace() << "Fields::constantValue starting" << std::endl;
+  oops::Log::trace() << classname() << "::constantValue starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -190,9 +242,12 @@
     }
   }
   fset_.set_dirty(false);
-  oops::Log::trace() << "Fields::constantValue end" << std::endl;
+
+  oops::Log::trace() << classname() << "::constantValue end" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::constantValue(const eckit::Configuration & config) {
   oops::Log::trace() << "Fields::constantValue starting" << std::endl;
   for (const auto & group : config.getSubConfigurations("constant group-specific value")) {
@@ -216,14 +271,18 @@
     }
   }
   fset_.set_dirty(false);
-  oops::Log::trace() << "Fields::constantValue end" << std::endl;
+
+  oops::Log::trace() << classname() << "::constantValue end" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 Fields & Fields::operator=(const Fields & rhs) {
-  oops::Log::trace() << "Fields::operator=(const Fields & rhs) starting" << std::endl;
-  for (const auto & var : vars_) {
-    atlas::Field field = fset_[var.name()];
-    atlas::Field fieldRhs = rhs.fset_[var.name()];
+  oops::Log::trace() << classname() << "::operator= starting" << std::endl;
+
+  for (const auto & var : vars_.variables()) {
+    atlas::Field field = fset_[var];
+    atlas::Field fieldRhs = rhs.fset_[var];
     if (field.rank() == 2) {
       auto view = atlas::array::make_view<double, 2>(field);
       auto viewRhs = atlas::array::make_view<double, 2>(fieldRhs);
@@ -236,17 +295,34 @@
     }
   }
   time_ = rhs.time_;
-  oops::Log::trace() << "Fields::operator=(const Fields & rhs) end" << std::endl;
+
+  oops::Log::trace() << classname() << "::operator= end" << std::endl;
   return *this;
 }
+
 // -----------------------------------------------------------------------------
+
 Fields & Fields::operator+=(const Fields & rhs) {
-  oops::Log::trace() << "Fields::operator+=(const Fields & rhs) starting" << std::endl;
+  oops::Log::trace() << classname() << "::operator+= starting" << std::endl;
+
+  // Right-hand side fieldset
+  atlas::FieldSet fsetRhs;
+  if (geom_->grid() == rhs.geom_->grid() && geom_->halo() == rhs.geom_->halo()) {
+    // Same geometry
+    fsetRhs = util::shareFields(rhs.fset_);
+  } else {
+    // Interpolate
+    const Fields rhsInterp(rhs, *geom_);
+
+    // Copy fieldset
+    fsetRhs = util::copyFieldSet(rhsInterp.fset_);
+  }
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
     const auto gmaskView = atlas::array::make_view<int, 2>(geom_->fields()[gmaskName]);
-    atlas::Field fieldRhs = rhs.fset_[var.name()];
+    atlas::Field fieldRhs = fsetRhs[var.name()];
     if (field.rank() == 2) {
       auto view = atlas::array::make_view<double, 2>(field);
       auto viewRhs = atlas::array::make_view<double, 2>(fieldRhs);
@@ -260,12 +336,16 @@
       field.set_dirty(field.dirty() || fieldRhs.dirty());
     }
   }
-  oops::Log::trace() << "Fields::operator+=(const Fields & rhs) done" << std::endl;
+
+  oops::Log::trace() << classname() << "::operator+= done" << std::endl;
   return *this;
 }
+
 // -----------------------------------------------------------------------------
+
 Fields & Fields::operator-=(const Fields & rhs) {
-  oops::Log::trace() << "Fields::operator-=(const Fields & rhs) starting" << std::endl;
+  oops::Log::trace() << classname() << "::operator-= starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -284,12 +364,16 @@
       field.set_dirty(field.dirty() || fieldRhs.dirty());
     }
   }
-  oops::Log::trace() << "Fields::operator-=(const Fields & rhs) done" << std::endl;
+
+  oops::Log::trace() << classname() << "::operator-= done" << std::endl;
   return *this;
 }
+
 // -----------------------------------------------------------------------------
+
 Fields & Fields::operator*=(const double & zz) {
-  oops::Log::trace() << "Fields::operator*=(const Fields & rhs) starting" << std::endl;
+  oops::Log::trace() << classname() << "::operator*= starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -305,12 +389,17 @@
       }
     }
   }
-  oops::Log::trace() << "Fields::operator*=(const Fields & rhs) done" << std::endl;
+
+  oops::Log::trace() << classname() << "::operator*= done" << std::endl;
   return *this;
 }
+
 // -----------------------------------------------------------------------------
-void Fields::axpy(const double & zz, const Fields & rhs) {
-  oops::Log::trace() << "Fields::axpy starting" << std::endl;
+
+void Fields::axpy(const double & zz,
+                  const Fields & rhs) {
+  oops::Log::trace() << classname() << "::axpy starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -329,13 +418,18 @@
       field.set_dirty(field.dirty() || fieldRhs.dirty());
     }
   }
-  oops::Log::trace() << "Fields::axpy done" << std::endl;
+
+  oops::Log::trace() << classname() << "::axpy done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 double Fields::dot_product_with(const Fields & fld2) const {
-  oops::Log::trace() << "Fields::dot_product_with starting" << std::endl;
+  oops::Log::trace() << classname() << "::dot_product_with starting" << std::endl;
+
   double zz = 0;
   const auto ghostView = atlas::array::make_view<int, 1>(geom_->functionSpace().ghost());
+  const auto ownedView = atlas::array::make_view<int, 2>(geom_->fields().field("owned"));
   for (const auto & var : vars_) {
     atlas::Field field1 = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -346,7 +440,7 @@
       auto view2 = atlas::array::make_view<double, 2>(field2);
       for (atlas::idx_t jnode = 0; jnode < field1.shape(0); ++jnode) {
         for (atlas::idx_t jlevel = 0; jlevel < field1.shape(1); ++jlevel) {
-          if (gmaskView(jnode, jlevel) == 1 && ghostView(jnode) == 0) {
+          if (gmaskView(jnode, jlevel) == 1 && ghostView(jnode) == 0 && ownedView(jnode, 0) == 1) {
             zz += view1(jnode, jlevel)*view2(jnode, jlevel);
           }
         }
@@ -354,12 +448,15 @@
     }
   }
   geom_->getComm().allReduceInPlace(zz, eckit::mpi::sum());
-  oops::Log::trace() << "Fields::dot_product_with done" << std::endl;
+  oops::Log::trace() << classname() << "::dot_product_with done" << std::endl;
   return zz;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::schur_product_with(const Fields & dx) {
-  oops::Log::trace() << "Fields::schur_product_with starting" << std::endl;
+  oops::Log::trace() << classname() << "::schur_product_with starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -378,11 +475,15 @@
       field.set_dirty(field.dirty() || fieldDx.dirty());
     }
   }
-  oops::Log::trace() << "Fields::schur_product_with done" << std::endl;
+
+  oops::Log::trace() << classname() << "::schur_product_with done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::random() {
-  oops::Log::trace() << "Fields::random starting" << std::endl;
+  oops::Log::trace() << classname() << "::random starting" << std::endl;
+
   fset_.clear();
   for (size_t groupIndex = 0; groupIndex < geom_->groups(); ++groupIndex) {
     // Mask and ghost points fields
@@ -453,7 +554,8 @@
         fs.gather(localMasks, globalMasks);
       }
     } else {
-      ABORT(geom_->functionSpace().type() + " function space not supported yet");
+      throw eckit::NotImplemented(geom_->functionSpace().type() +
+        " function space not supported yet", Here());
     }
 
     if (geom_->getComm().rank() == 0) {
@@ -510,7 +612,8 @@
         fs.scatter(globalData, localData);
       }
     } else {
-      ABORT(geom_->functionSpace().type() + " function space not supported yet");
+      throw eckit::NotImplemented(geom_->functionSpace().type() +
+        " function space not supported yet", Here());
     }
 
     // Copy data
@@ -523,11 +626,17 @@
 
   fset_.set_dirty();  // code is too complicated, mark dirty to be safe
 
+  // Set duplicate points to the same value
+  resetDuplicatePoints();
+
   oops::Log::trace() << "Fields::random done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::dirac(const eckit::Configuration & config) {
-  oops::Log::trace() << "Fields::dirac starting" << std::endl;
+  oops::Log::trace() << classname() << "::dirac starting" << std::endl;
+
   // Get dirac specifications
   std::vector<double> lon = config.getDoubleVector("lon");
   std::vector<double> lat = config.getDoubleVector("lat");
@@ -535,22 +644,31 @@
   std::vector<std::string> variable = config.getStringVector("variable");
 
   // Check sizes
-  if (lon.size() != lat.size()) ABORT("Inconsistent dirac specification size");
-  if (lon.size() != level.size()) ABORT("Inconsistent dirac specification size");
-  if (lon.size() != variable.size()) ABORT("Inconsistent dirac specification size");
+  if (lon.size() != lat.size()) throw eckit::UserError("Inconsistent dirac specification size",
+    Here());
+  if (lon.size() != level.size()) throw eckit::UserError("Inconsistent dirac specification size",
+    Here());
+  if (lon.size() != variable.size()) throw eckit::UserError("Inconsistent dirac specification size",
+    Here());
 
   // Build KDTree for each MPI task
-  atlas::util::IndexKDTree search;
-  search.reserve(geom_->functionSpace().size());
   const auto ghostView = atlas::array::make_view<int, 1>(geom_->functionSpace().ghost());
+  const auto ownedView = atlas::array::make_view<int, 2>(geom_->fields().field("owned"));
   const auto lonlatView = atlas::array::make_view<double, 2>(geom_->functionSpace().lonlat());
   atlas::idx_t n = 0;
   for (atlas::idx_t jnode = 0; jnode < geom_->functionSpace().size(); ++jnode) {
-    if (ghostView(jnode) == 0) {
+    if ((ghostView(jnode) == 0) && (ownedView(jnode, 0) == 1)) {
+      ++n;
+    }
+  }
+  atlas::util::IndexKDTree search;
+  search.reserve(n);
+  for (atlas::idx_t jnode = 0; jnode < geom_->functionSpace().size(); ++jnode) {
+    if ((ghostView(jnode) == 0) && (ownedView(jnode, 0) == 1)) {
       atlas::PointLonLat pointLonLat(lonlatView(jnode, 0), lonlatView(jnode, 1));
       pointLonLat.normalise();
       atlas::PointXY point(pointLonLat);
-      search.insert(point, n++);
+      search.insert(point, jnode);
     }
   }
   search.build();
@@ -570,35 +688,68 @@
     // Search nearest neighbor
     size_t index = std::numeric_limits<size_t>::max();
     double distance = std::numeric_limits<double>::max();
+    bool potentialConflict = false;
     if (geom_->functionSpace().size() > 0) {
-      atlas::util::IndexKDTree::ValueList neighbor = search.closestPoints(pointLonLat, 1);
+      atlas::util::IndexKDTree::ValueList neighbor = search.closestPoints(pointLonLat, 2);
       index = neighbor[0].payload();
       distance = neighbor[0].distance();
+      potentialConflict = (std::abs(neighbor[0].distance()-neighbor[1].distance()) < 1.0e-12);
     }
     std::vector<double> distances(geom_->getComm().size());
-    geom_->getComm().gather(distance, distances, 0);
+    geom_->getComm().allGather(distance, distances.begin(), distances.end());
+    const std::vector<double>::iterator distanceMin = std::min_element(std::begin(distances),
+      std::end(distances));
+    size_t sameDistanceCount = 0;
+    for (size_t jj = 0; jj < geom_->getComm().size(); ++jj) {
+      if (std::abs(distances[jj]-*distanceMin) < 1.0e-12) {
+        ++sameDistanceCount;
+      }
+    }
+    if (sameDistanceCount > 1) {
+      throw eckit::UserError("requested dirac point exactly between two gridpoints", Here());
+    }
 
     // Find local task
-    size_t localTask(-1);
-    if (geom_->getComm().rank() == 0) {
-      localTask = std::distance(std::begin(distances), std::min_element(std::begin(distances),
-        std::end(distances)));
-    }
-    geom_->getComm().broadcast(localTask, 0);
+    size_t localTask = std::distance(std::begin(distances), distanceMin);
 
     if (geom_->getComm().rank() == localTask) {
+      // Check potential conflict
+      if (potentialConflict) {
+        throw eckit::UserError("requested dirac point exactly between two gridpoints", Here());
+      }
+
       // Add Dirac impulse
       if (field.rank() == 2) {
         auto view = atlas::array::make_view<double, 2>(field);
         view(index, level[jdir]-1) = 1.0;
       }
     }
+
+    // Print longitude / latitude / level
+    double lonDir = 0.0;
+    double latDir = 0.0;
+    if (geom_->getComm().rank() == localTask) {
+      lonDir = lonlatView(index, 0);
+      latDir = lonlatView(index, 1);
+    }
+    geom_->getComm().allReduceInPlace(lonDir, eckit::mpi::sum());
+    geom_->getComm().allReduceInPlace(latDir, eckit::mpi::sum());
+    oops::Log::info() << "Info     : Dirac point #" << jdir << ": " << lonDir << " / " << latDir
+      << " / " << level[jdir] << std::endl;
   }
-  oops::Log::trace() << "Fields::dirac done" << std::endl;
+
+  // Set duplicate points to the same value
+  resetDuplicatePoints();
+
+  oops::Log::trace() << classname() << "::dirac done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
-void Fields::diff(const Fields & x1, const Fields & x2) {
-  oops::Log::trace() << "Fields::diff starting" << std::endl;
+
+void Fields::diff(const Fields & x1,
+                  const Fields & x2) {
+  oops::Log::trace() << classname() << "::diff starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     const std::string gmaskName = "gmask_" + std::to_string(geom_->groupIndex(var.name()));
@@ -612,29 +763,40 @@
       for (atlas::idx_t jnode = 0; jnode < field.shape(0); ++jnode) {
         for (atlas::idx_t jlevel = 0; jlevel < field.shape(1); ++jlevel) {
           if (gmaskView(jnode, jlevel) == 1) {
-            view(jnode, jlevel) = viewx1(jnode, jlevel) - viewx2(jnode, jlevel);
+            view(jnode, jlevel) = viewx1(jnode, jlevel)-viewx2(jnode, jlevel);
           }
         }
       }
       field.set_dirty(fieldx1.dirty() || fieldx2.dirty());
     }
   }
-  oops::Log::trace() << "Fields::diff done" << std::endl;
+
+  oops::Log::trace() << classname() << "::diff done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::toFieldSet(atlas::FieldSet & fset) const {
-  oops::Log::trace() << "Fields::toFieldSet starting" << std::endl;
+  oops::Log::trace() << classname() << "::toFieldSet starting" << std::endl;
+
   // Share internal fieldset
   fset.clear();
   fset = util::shareFields(fset_);
-  for (auto field_external : fset) {
-    field_external.metadata().set("interp_type", "default");
+  for (auto field : fset) {
+    field.metadata().set("interp_type", "default");
+    field.set_dirty(fset_[field.name()].dirty());
   }
-  oops::Log::trace() << "Fields::toFieldSet done" << std::endl;
+
+  oops::Log::trace() << classname() << "::toFieldSet done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::fromFieldSet(const atlas::FieldSet & fset) {
-  oops::Log::trace() << "Fields::fromFieldSet starting" << std::endl;
+  oops::Log::trace() << classname() << "::fromFieldSet starting" << std::endl;
+
+  // Check input fieldset
+  ASSERT(!fset.empty());
 
   // Reset internal fieldset
   fset_.clear();
@@ -646,54 +808,23 @@
     vars_[field.name()].setLevels(field.shape(1));
   }
 
-  if (geom_->gridType() == "regular_lonlat") {
-    // Reset poles points
-    for (auto field_internal : fset_) {
-      atlas::functionspace::StructuredColumns fs(field_internal.functionspace());
-      atlas::StructuredGrid grid = fs.grid();
-      auto view = atlas::array::make_view<double, 2>(field_internal);
-      auto view_i = atlas::array::make_view<int, 1>(fs.index_i());
-      auto view_j = atlas::array::make_view<int, 1>(fs.index_j());
-      std::vector<double> north(field_internal.shape(1), 0.0);
-      std::vector<double> south(field_internal.shape(1), 0.0);
-      for (atlas::idx_t j = fs.j_begin(); j < fs.j_end(); ++j) {
-        for (atlas::idx_t i = fs.i_begin(j); i < fs.i_end(j); ++i) {
-          atlas::idx_t jnode = fs.index(i, j);
-          if ((view_j(jnode) == 1)  && (view_i(jnode) == 1)) {
-            for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
-              north[jlevel] = view(jnode, jlevel);
-            }
-          }
-          if ((view_j(jnode) == grid.ny())  && (view_i(jnode) == 1)) {
-            for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
-              south[jlevel] = view(jnode, jlevel);
-            }
-          }
-        }
-      }
-      geom_->getComm().allReduceInPlace(north.begin(), north.end(), eckit::mpi::sum());
-      geom_->getComm().allReduceInPlace(south.begin(), south.end(), eckit::mpi::sum());
-      for (atlas::idx_t j = fs.j_begin_halo(); j < fs.j_end_halo(); ++j) {
-        for (atlas::idx_t i = fs.i_begin_halo(j); i < fs.i_end_halo(j); ++i) {
-          atlas::idx_t jnode = fs.index(i, j);
-          if (view_j(jnode) == 1) {
-            for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
-              view(jnode, jlevel) = north[jlevel];
-            }
-          }
-          if (view_j(jnode) == grid.ny()) {
-            for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
-              view(jnode, jlevel) = south[jlevel];
-            }
-          }
-        }
-      }
-    }
-  }
-  oops::Log::trace() << "Fields::fromFieldSet done" << std::endl;
+  // Set duplicate points to the same value
+  resetDuplicatePoints();
+
+  oops::Log::trace() << classname() << "::fromFieldSet done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::read(const eckit::Configuration & config) {
+  oops::Log::trace() << classname() << "::read starting" << std::endl;
+
+  // Get IO format
+  const std::string ioFormat = config.getString("format", "default");
+
+  // Set FieldsIO
+  std::unique_ptr<FieldsIOBase> fieldsIO(FieldsIOFactory::create(ioFormat));
+
   // Update variables names
   Variables vars_in_file;
   for (const auto & var : vars_) {
@@ -707,11 +838,7 @@
   }
 
   // Read fieldset
-  util::readFieldSet(geom_->getComm(),
-                     geom_->functionSpace(),
-                     vars_in_file,
-                     config,
-                     fset_);
+  fieldsIO->read(*geom_, vars_in_file, config, fset_);
 
   // Rename fields
   for (auto & field : fset_) {
@@ -722,10 +849,27 @@
     }
   }
 
+  // Set interpolation type
+  for (auto field : fset_) {
+    field.metadata().set("interp_type", "default");
+  }
+
   fset_.set_dirty();
+
+  oops::Log::trace() << classname() << "::read done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::write(const eckit::Configuration & config) const {
+  oops::Log::trace() << classname() << "::write starting" << std::endl;
+
+  // Get IO format
+  const std::string ioFormat = config.getString("format", "default");
+
+  // Set FieldsIO
+  std::unique_ptr<FieldsIOBase> fieldsIO(FieldsIOFactory::create(ioFormat));
+
   // Copy fieldset
   atlas::FieldSet fset = util::copyFieldSet(fset_);
 
@@ -738,8 +882,8 @@
     }
   }
 
-  // Write fieldset
-  util::writeFieldSet(geom_->getComm(), config, fset);
+  // Write fields
+  fieldsIO->write(*geom_, config, fset);
 
   if (geom_->mesh().generated() && config.getBool("write gmsh", false)) {
     // GMSH file path
@@ -757,13 +901,22 @@
     gmsh.write(geom_->mesh());
     gmsh.write(fset, fset[0].functionspace());
   }
+
+  oops::Log::trace() << classname() << "::write done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 double Fields::norm() const {
+  oops::Log::trace() << classname() << "::norm" << std::endl;
   return util::normFieldSet(fset_, vars_.variables(), geom_->getComm());
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::print(std::ostream & os) const {
+  oops::Log::trace() << classname() << "::print starting" << std::endl;
+
   os << std::endl;
   os << *geom_;
   std::string prefix;
@@ -792,9 +945,15 @@
     zz = sqrt(zz);
     os << prefix << "  " << var.name() << ": " << zz;
   }
+
+  oops::Log::trace() << classname() << "::print done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
+
 size_t Fields::serialSize() const {
+  oops::Log::trace() << classname() << "::serialSize starting" << std::endl;
+
   size_t nn = 0;
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
@@ -802,10 +961,16 @@
       nn += field.shape(0)*field.shape(1);
     }
   }
+
+  oops::Log::trace() << classname() << "::serialSize done" << std::endl;
   return nn;
 }
+
 // -----------------------------------------------------------------------------
+
 void Fields::serialize(std::vector<double> & vect)  const {
+  oops::Log::trace() << classname() << "::serialize starting" << std::endl;
+
   for (const auto & var : vars_) {
     const atlas::Field field = fset_[var.name()];
     if (field.rank() == 2) {
@@ -817,9 +982,16 @@
       }
     }
   }
+
+  oops::Log::trace() << classname() << "::serialize done" << std::endl;
 }
+
 // -----------------------------------------------------------------------------
-void Fields::deserialize(const std::vector<double> & vect, size_t & index) {
+
+void Fields::deserialize(const std::vector<double> & vect,
+                         size_t & index) {
+  oops::Log::trace() << classname() << "::deserialize starting" << std::endl;
+
   for (const auto & var : vars_) {
     atlas::Field field = fset_[var.name()];
     if (field.rank() == 2) {
@@ -832,6 +1004,103 @@
       }
     }
   }
+
+  oops::Log::trace() << classname() << "::deserialize done" << std::endl;
+}
+
+// -----------------------------------------------------------------------------
+
+std::vector<Interpolation>::iterator Fields::setupGridInterpolation(const Geometry & srcGeom)
+  const {
+  oops::Log::trace() << classname() << "::setupGridInterpolation starting" << std::endl;
+
+  // Compare with exisiting UIDs
+  for (auto it = interpolations().begin(); it != interpolations().end(); ++it) {
+    if ((it->srcUid() == srcGeom.grid().uid()) && (it->dstUid() == geom_->grid().uid())) {
+      oops::Log::trace() << classname() << "::setupGridInterpolation done" << std::endl;
+      return it;
+    }
+  }
+
+  // Create interpolation
+  Interpolation interpolation(geom_->interpolation(), geom_->getComm(), srcGeom.partitioner(),
+    srcGeom.functionSpace(), geom_->grid(), geom_->functionSpace());
+
+  // Insert new interpolation
+  interpolations().push_back(interpolation);
+
+  oops::Log::trace() << classname() << "::setupGridInterpolation done" << std::endl;
+  return std::prev(interpolations().end());
+}
+
+// -----------------------------------------------------------------------------
+
+void Fields::resetDuplicatePoints() {
+  oops::Log::trace() << classname() << "::resetDuplicatePoints starting" << std::endl;
+
+  if (geom_->duplicatePoints()) {
+    if (geom_->gridType() == "regular_lonlat") {
+      // Deal with poles
+      for (auto field_internal : fset_) {
+        // Get first longitude value
+        atlas::functionspace::StructuredColumns fs(field_internal.functionspace());
+        atlas::StructuredGrid grid = fs.grid();
+        auto view = atlas::array::make_view<double, 2>(field_internal);
+        auto view_i = atlas::array::make_view<int, 1>(fs.index_i());
+        auto view_j = atlas::array::make_view<int, 1>(fs.index_j());
+        std::vector<double> north(field_internal.shape(1), 0.0);
+        std::vector<double> south(field_internal.shape(1), 0.0);
+        for (atlas::idx_t j = fs.j_begin(); j < fs.j_end(); ++j) {
+          for (atlas::idx_t i = fs.i_begin(j); i < fs.i_end(j); ++i) {
+            atlas::idx_t jnode = fs.index(i, j);
+            if (view_i(jnode) == 1) {
+              if (view_j(jnode) == 1) {
+                for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
+                  north[jlevel] = view(jnode, jlevel);
+                }
+              }
+              if (view_j(jnode) == grid.ny()) {
+                for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
+                  south[jlevel] = view(jnode, jlevel);
+                }
+              }
+            }
+          }
+        }
+
+        // Reduce
+        geom_->getComm().allReduceInPlace(north.begin(), north.end(), eckit::mpi::sum());
+        geom_->getComm().allReduceInPlace(south.begin(), south.end(), eckit::mpi::sum());
+
+        // Copy value
+        for (atlas::idx_t j = fs.j_begin_halo(); j < fs.j_end_halo(); ++j) {
+          for (atlas::idx_t i = fs.i_begin_halo(j); i < fs.i_end_halo(j); ++i) {
+            atlas::idx_t jnode = fs.index(i, j);
+            if (view_j(jnode) == 1) {
+              for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
+                view(jnode, jlevel) = north[jlevel];
+              }
+            }
+            if (view_j(jnode) == grid.ny()) {
+              for (atlas::idx_t jlevel = 0; jlevel < field_internal.shape(1); ++jlevel) {
+                view(jnode, jlevel) = south[jlevel];
+              }
+            }
+          }
+        }
+      }
+    } else {
+      throw eckit::NotImplemented("duplicate points not supported for this grid", Here());
+    }
+  }
+
+  oops::Log::trace() << classname() << "::resetDuplicatePoints done" << std::endl;
 }
+
+// -----------------------------------------------------------------------------
+
+#include "src/FieldsECImp.h"
+
 // -----------------------------------------------------------------------------
+
 }  // namespace quench
