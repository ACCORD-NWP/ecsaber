--- /home/benjaminm/code/oops-bundle/ecsaber/oops-patch/src/oops/util/FunctionSpaceHelpers.cc.tmp.bak	2024-03-07 11:39:32.366082689 +0100
+++ /home/benjaminm/code/oops-bundle/ecsaber/oops-patch/src/oops/util/FunctionSpaceHelpers.cc	2024-03-07 11:31:51.493560112 +0100
@@ -57,8 +57,28 @@
     ASSERT(gridType != "unstructured");
 
     const size_t halo = config.getUnsigned("halo", 0);
-    functionSpace = atlas::functionspace::StructuredColumns(grid, partitioner,
-                                                            atlas::option::halo(halo));
+    if (noPointOnLastTask && (comm.size() > 1)) {
+      // Create distribution from partitioner
+      std::vector<int>partition(grid.size());
+      partitioner.partition(grid, &partition[0]);
+
+      // Create distribution and mesh
+      atlas::grid::Distribution distribution;
+      atlas::Mesh mesh;
+      setupStructuredMeshWithCustomPartition(comm, grid, partition, distribution, mesh);
+
+      // Create functionspace from distribution
+      functionSpace = atlas::functionspace::StructuredColumns(grid, distribution,
+                                                              atlas::option::halo(halo));
+
+    } else {
+      // Create functionspace from partitioner
+      functionSpace = atlas::functionspace::StructuredColumns(grid, partitioner,
+                                                              atlas::option::halo(halo));
+
+      // Create mesh from partitioner
+      mesh = atlas::MeshGenerator("structured").generate(grid, partitioner);
+    }
 
     // Bugfix for regional grids
     // It seems that the content of lonlat for a regional function space is actually the xy
@@ -77,8 +97,6 @@
         lonlat(jj, 1) = lonlatPoint[1];
       }
     }
-
-    mesh = atlas::MeshGenerator("structured").generate(grid, partitioner);
   } else if (functionSpaceName == "NodeColumns") {
     if (grid.name().compare(0, 2, std::string{"CS"}) == 0) {
       // NodeColumns from a CubedSphere grid/mesh
@@ -130,5 +148,41 @@
 }
 
 // -----------------------------------------------------------------------------
+
+void setupStructuredMeshWithCustomPartition(const eckit::mpi::Comm & comm,
+                                            const atlas::Grid & grid,
+                                            const std::vector<int> & partition,
+                                            atlas::grid::Distribution & distribution,
+                                            atlas::Mesh & mesh) {
+  // Create custom distribution
+  std::vector<int> partitionCopy = partition;
+  distribution = atlas::grid::Distribution(comm.size(), grid.size(), partitionCopy.data());
+
+  // Count number of cells for each MPI task
+  std::vector<size_t> nb_cells(comm.size(), 0);
+  for (atlas::idx_t jj = 0; jj < grid.size(); ++jj) {
+    ++nb_cells[partition[jj]];
+  }
+
+  // Get number of task with points (effective size) and mapping
+  size_t effectiveSize = 0;
+  std::vector<size_t> mapping(comm.size());
+  for (size_t jt = 0; jt < comm.size(); ++jt) {
+    if (nb_cells[jt] > 0) {
+      mapping[jt] = effectiveSize;
+      ++effectiveSize;
+    }
+  }
+
+  // Create mesh from distribution
+  atlas::util::Config meshConfig(grid.meshgenerator());
+  meshConfig.set("part", mapping[comm.rank()]);
+  meshConfig.set("nb_parts", effectiveSize);
+  meshConfig.set("mpi_comm", comm.name());
+  const atlas::StructuredMeshGenerator gen(meshConfig);
+  mesh = gen(grid, distribution);
+}
+
+// -----------------------------------------------------------------------------
 
 }  // namespace util
