--- /home/benjaminm/code/oops-bundle/ecsaber/oops-patch/src/oops/base/GeometryData.cc.tmp	2024-03-07 11:39:32.106082398 +0100
+++ /home/benjaminm/code/oops-bundle/ecsaber/oops-patch/src/oops/base/GeometryData.cc	2024-03-07 11:31:54.721563075 +0100
@@ -9,6 +9,7 @@
 
 #include <algorithm>
 
+#include "atlas/grid/Distribution.h"
 #include "atlas/grid/Grid.h"
 #include "atlas/grid/Partitioner.h"
 #include "atlas/interpolation/element/Triag3D.h"
@@ -20,6 +21,7 @@
 
 #include "oops/mpi/mpi.h"
 #include "oops/util/abor1_cpp.h"
+#include "oops/util/FunctionSpaceHelpers.h"
 #include "oops/util/Logger.h"
 #include "oops/util/Timer.h"
 
@@ -64,7 +66,7 @@
 
 GeometryData::GeometryData(const atlas::FunctionSpace & fspace, const atlas::FieldSet & fset,
                            const bool topdown, const eckit::mpi::Comm & comm):
-  fspace_(fspace), fset_(fset), comm_(&comm), topdown_(topdown),
+  fspace_(fspace), fset_(fset), comm_(comm), topdown_(topdown),
   firstTriangulationOfQuadsIsDelaunay_(),
   earth_(atlas::util::Earth::radius()), globalNodeTree_(earth_), localCellCenterTree_(earth_)
 {
@@ -91,7 +93,7 @@
   atlas::PointLonLat target(lon, lat);
   target.normalise();
   const int itask = globalNodeTree_.closestPoint(target).payload();
-  ASSERT(itask >= 0 && (size_t)itask < comm_->size());
+  ASSERT(itask >= 0 && (size_t)itask < comm_.size());
   return itask;
 }
 
@@ -202,7 +204,7 @@
                                  const std::vector<double> & lons) {
   ASSERT(globalNodeTree_.empty());
   util::Timer timer("oops::GeometryData", "setGlobalTree");
-  const size_t ntasks = comm_->size();
+  const size_t ntasks = comm_.size();
 
 // Local latitudes and longitudes
   const size_t sizel = lats.size();
@@ -214,13 +216,13 @@
 
 // Collect global grid lats and lons
   std::vector<size_t> sizes(ntasks);
-  comm_->allGather(sizel, sizes.begin(), sizes.end());
+  comm_.allGather(sizel, sizes.begin(), sizes.end());
 
   size_t sizeg = 0;
   for (size_t jtask = 0; jtask < ntasks; ++jtask) sizeg += sizes[jtask];
 
   std::vector<double> latlon_global(2*sizeg);
-  mpi::allGatherv(*comm_, latlon, latlon_global);
+  mpi::allGatherv(comm_, latlon, latlon_global);
 
 // Arrange coordinates and task index for kd-tree
   std::vector<double> latglo(sizeg), longlo(sizeg);
@@ -257,8 +259,33 @@
   } else if (fspace_.type() == "StructuredColumns") {
     const atlas::functionspace::StructuredColumns structuredcolumns(fspace_);
     const atlas::Grid & grid = structuredcolumns.grid();
-    const atlas::StructuredMeshGenerator gen(grid.meshgenerator());
-    mesh_ = gen(grid, atlas::grid::Partitioner(fspace_.distribution()));
+    if (fspace_.distribution() == "custom") {
+      // Gather global partition field on root processor
+      atlas::Field globalPartition = fspace_.createField<int>(
+        atlas::option::name("partition") | atlas::option::global());
+      fspace_.gather(fspace_.partition(), globalPartition);
+
+      // Transform to a global partition vector
+      std::vector<int> partition(grid.size());
+      if (comm_.rank() == 0) {
+        ASSERT(grid.size() == static_cast<int>(globalPartition.size()));
+        const auto globalPartitionView = atlas::array::make_view<int, 1>(globalPartition);
+        for (atlas::idx_t jj = 0; jj < grid.size(); ++jj) {
+          partition[jj] = globalPartitionView(jj);
+        }
+      }
+
+      // Broadcast global partition vector
+      comm_.broadcast(partition, 0);
+
+      // Create distribution and mesh
+      atlas::grid::Distribution distribution;
+      util::setupStructuredMeshWithCustomPartition(comm_, grid, partition, distribution, mesh_);
+    } else {
+      // Create mesh
+      const atlas::StructuredMeshGenerator gen(grid.meshgenerator());
+      mesh_ = gen(grid, atlas::grid::Partitioner(fspace_.distribution()));
+    }
   } else {
     ABORT(fspace_.type() + " function space not supported yet");
   }
